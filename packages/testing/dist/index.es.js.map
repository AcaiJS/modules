{"version":3,"file":"index.es.js","sources":["../src/utils/group.ts","../src/utils/general.ts","../src/utils/deepCompare.ts","../src/utils/assertions.ts","../src/utils/test.ts","../src/utils/context.ts","../src/utils/curr.ts","../src/modules/cache.ts","../src/modules/run.ts","../src/modules/test.ts","../src/modules/find.ts","../src/modules/group.ts","../src/modules/only.ts","../src/modules/except.ts","../src/modules/tag.ts","../src/modules/print.ts","../src/modules/runAndPrint.ts","../src/index.ts"],"sourcesContent":["// Interface\nimport ContextInterface \t\tfrom \"../interfaces/context\"\nimport GroupAuxiliaryInterface \tfrom \"../interfaces/groupAuxiliary\"\n\ntype GroupsInterface = {ctx: ContextInterface; cb: (aux: GroupAuxiliaryInterface) => void};\n\nlet groups: GroupsInterface[] = []\n\nexport const get = () => groups\n\nexport const append = (ctx: Partial<ContextInterface>) => {\n\tconst lastctx = groups[groups.length - 1].ctx\n\n\tgroups[groups.length - 1].ctx = {\n\t\t...groups[groups.length - 1].ctx,\n\t\t...ctx,\n\n\t\tgroup\t: [...lastctx.group\t, ...(ctx.group || [])],\n\t\ttags\t: [...lastctx.tags\t, ...(ctx.tags || [])],\n\n\t\t// callbacks\n\t\tbeforeAll\t: [...lastctx.beforeAll\t, ...(ctx.beforeAll || [])],\n\t\tbeforeEach\t: [...lastctx.beforeEach, ...(ctx.beforeEach || [])],\n\t\tafterAll\t: [...lastctx.afterAll\t, ...(ctx.afterAll || [])],\n\t\tafterEach\t: [...lastctx.afterEach\t, ...(ctx.afterEach || [])],\n\t}\n}\nexport const add = (test: GroupsInterface) => {\n\tgroups.push(test)\n}\nexport const clear = () => {\n\tgroups = []\n}\n","export const getStackTrace = (index = 4, prestack?) => {\n\tlet stack = prestack?.stack\n\n\tif (!stack) {\n\t\ttry {\n\t\t\tthrow new Error(\"\")\n\t\t}\n\t\tcatch (error) {\n\t\t\tstack = (error as any).stack || \"\"\n\t\t}\n\t}\n\n\treturn stack.split(\"\\n\").slice(index).join(\"\\n\")\n}\n\nexport const isArrayEquals = (arr1: string[], arr2: string[]) => {\n\tif (arr1.length !== arr2.length) return false\n\n\treturn arr1.filter((item, index) => item !== arr2[index]).length === 0\n}\n\nexport const repeatString = (text: string, times: number) => {\n\tlet response = \"\"\n\n\tfor (let i = 0; i < times; i++) {\n\t\tresponse += text\n\t}\n\n\treturn response\n}","export default function deepCompare( x: unknown, y: unknown ) {\n\t// if both x and y are null or undefined and exactly the same\n\tif ( x === y ) return true\n\n\t// if they are not strictly equal, they both need to be Objects\n\tif ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false\n\n\t// they must have the exact same prototype chain, the closest we can do is\n\t// test there constructor.\n\tif ( x.constructor !== y.constructor ) return false\n\n\tfor ( const p in x ) {\n\t\t// other properties were tested using x.constructor === y.constructor\n\t\tif ( ! x.hasOwnProperty( p ) ) continue\n\n\t\t// allows to compare x[ p ] and y[ p ] when set to undefined\n\t\tif ( ! y.hasOwnProperty( p ) ) return false\n\n\t\t// if they have the same strict value or identity then they are equal\n\t\tif ( x[ p ] === y[ p ] ) continue\n\n\t\t// Numbers, Strings, Functions, Booleans must be strictly equal\n\t\tif ( typeof( x[ p ] ) !== \"object\" ) return false\n\n\t\t// Objects and Arrays must be tested recursively\n\t\tif ( ! deepCompare( x[ p ],  y[ p ] ) ) return false\n\t}\n\n\tfor ( const p in y )\n\t// allows x[ p ] to be set to undefined\n\t\tif ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) )\n\t\t\treturn false\n\n\treturn true\n}","// Interfaces\r\nimport TestInterface \tfrom \"../interfaces/testQueue\"\r\nimport ExpectInterface \tfrom \"../interfaces/expect\"\r\n\r\n// Utils\r\nimport { getStackTrace } \tfrom \"./general\"\r\nimport deepCompare from \"./deepCompare\"\r\n\r\nconst buildResponse = (type: keyof ExpectInterface, success: boolean, message?: string, data: any[] = []) => {\r\n\treturn {\r\n\t\ttype,\r\n\t\tfail: !success,\r\n\t\tmessage: success ? undefined:message,\r\n\t\tstack: success ? undefined:getStackTrace(),\r\n\t\tdata,\r\n\t}\r\n}\r\nconst buildTestAssertion = (test: TestInterface) => {\r\n\treturn (valueToAssert: unknown) => {\r\n\t\tconst assertions = function (this: ExpectInterface) {\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toBe\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toBe = (valueToTest) => {\r\n\t\t\t\tconst passes = deepCompare(valueToAssert, valueToTest)\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toBe\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`${valueToAssert} is not equal to ${valueToTest}`,\r\n\t\t\t\t\t[[\"expected\", valueToTest], [\"received\", valueToAssert]],\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toNotBe\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toNotBe = (valueToTest) => {\r\n\t\t\t\tconst passes \t= valueToAssert !== valueToTest\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toNotBe\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`\"${valueToAssert}\" shouldn't be equal to ${valueToTest}`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toBeTypeOf\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toBeTypeOf = (valueToTest) => {\r\n\t\t\t\tconst passes = valueToTest === typeof valueToAssert\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toBeTypeOf\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`\"${valueToAssert}\" is not of the type ${valueToTest}`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toBeDefined\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toBeDefined = () => {\r\n\t\t\t\tconst passes \t= valueToAssert !== undefined\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toBeDefined\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`\"${valueToAssert}\" is not defined`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toBeUndefined\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toBeUndefined = () => {\r\n\t\t\t\tconst passes \t= valueToAssert === undefined\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toBeUndefined\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`\"${valueToAssert}\" is defined`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toBeNull\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toBeNull = () => {\r\n\t\t\t\tconst passes \t= valueToAssert === null\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toBeNull\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`\"${valueToAssert}\" is not null`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toNotBeNull\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toNotBeNull = () => {\r\n\t\t\t\tconst passes \t= valueToAssert !== null\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toNotBeNull\",\r\n\t\t\t\t\tpasses,\r\n\t\t\t\t\t`\"${valueToAssert}\" is null`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toThrow\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toThrow = (error?: any) => {\r\n\t\t\t\tconst obj = {} as any\r\n\r\n\t\t\t\tobj.async = (async function () {\r\n\t\t\t\t\tlet fails = true as any\r\n\t\t\t\t\tlet errorThrown\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait (valueToAssert as () => void | Promise<void>)()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\terrorThrown = e\r\n\t\t\t\t\t\tif (error) fails = deepCompare(e, error) ? false : `\"${valueToAssert}\" didn't match the exception ${error}`\r\n\t\t\t\t\t\telse fails = false\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst response = buildResponse(\r\n\t\t\t\t\t\t\"toThrow\",\r\n\t\t\t\t\t\t!fails,\r\n\t\t\t\t\t\tfails || `\"${valueToAssert}\" dind't throw an exception`,\r\n\t\t\t\t\t\terror ? [[\"expected\", error], [\"received\", errorThrown]] : undefined,\r\n\t\t\t\t\t)\r\n\r\n\t\t\t\t\tObject.keys(response).forEach(key => obj[key] = response[key])\r\n\t\t\t\t})\r\n\r\n\t\t\t\ttest.assertions.push(obj)\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// cache\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.cache = (title?: string) => {\r\n\t\t\t\ttest.messages.push([valueToAssert, title])\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\t// -------------------------------------------------\r\n\t\t\t// toContain\r\n\t\t\t// -------------------------------------------------\r\n\r\n\t\t\tthis.toContain = (contain: string | string[]) => {\r\n\t\t\t\tlet remains: string[] = []\r\n\r\n\t\t\t\tif (Array.isArray(valueToAssert)) {\r\n\t\t\t\t\tconst compare = Array.isArray(contain) ? contain:[contain]\r\n\r\n\t\t\t\t\tremains = compare.filter(i => valueToAssert.find(x => x !== i))\r\n\t\t\t\t}\r\n\t\t\t\telse if (typeof valueToAssert === \"object\") {\r\n\t\t\t\t\tconst keys = Object.keys(valueToAssert || {})\r\n\t\t\t\t\tconst compare = Array.isArray(contain) ? contain:[contain]\r\n\r\n\t\t\t\t\tremains = compare.filter(i => keys.find(x => x !== i))\r\n\t\t\t\t}\r\n\t\t\t\telse if (typeof valueToAssert === \"string\") {\r\n\t\t\t\t\tconst compare = Array.isArray(contain) ? contain:[contain]\r\n\r\n\t\t\t\t\tremains = compare.filter(i => !valueToAssert.match(i))\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttest.assertions.push(buildResponse(\r\n\t\t\t\t\t\"toContain\",\r\n\t\t\t\t\tremains.length === 0,\r\n\t\t\t\t\t`\"${valueToAssert}\" dind't contain values: ${remains.join(\", \")}`,\r\n\t\t\t\t))\r\n\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\r\n\t\t\treturn this\r\n\t\t}\r\n\r\n\t\treturn assertions.bind({} as ExpectInterface)()\r\n\t}\r\n}\r\n\r\nexport default buildTestAssertion","// Interface\nimport TestInterface, { TestArgumentInterface } from \"../interfaces/testQueue\"\n\n// Utils\nimport assertions\t\t\tfrom \"./assertions\"\nimport { getStackTrace, isArrayEquals }\tfrom \"./general\"\n\nconst tests: TestInterface[] = []\nlet only \t= false\nlet except \t= false\n\nexport const get = (tag: string[], filter = false) => {\n\treturn tests\n\t\t.filter(test => {\n\t\t\tif (filter) {\n\t\t\t\tif (only) \t\treturn test.only\n\t\t\t\tif (except) \treturn !test.except\n\t\t\t\tif (tag.length) return tag.find(tag => test.tags.find(subtag => subtag === tag))\n\t\t\t}\n\n\t\t\treturn true\n\t\t})\n\t\t.sort((test1, test2) => {\n\t\t\t// same group, keep it as it is\n\t\t\tif (isArrayEquals(test1.group, test2.group)) return 0\n\n\t\t\tif (test1.group.length > test2.group.length)\n\t\t\t\treturn test1.group.filter((item, index) => item === test2.group[index]).length - 1\n\n\t\t\treturn test2.group.filter((item, index) => item === test1.group[index]).length + 1\n\t\t})\n}\n\nexport const append = (test: Partial<TestInterface>) => {\n\ttests[tests.length - 1] = {\n\t\t...tests[tests.length - 1],\n\t\t...test,\n\t\ttags: [...(tests[tests.length - 1].tags || []), ...(test.tags || [])],\n\t\tmessages: [...(tests[tests.length - 1].messages || []), ...(test.messages || [])],\n\t}\n}\n\nexport const add = (pretest: Omit<TestArgumentInterface, \"fail\">) => {\n\t// filter for perfomance\n\tif (pretest.only) \t\tonly \t= true\n\tif (pretest.except) \texcept \t= true\n\n\t// build test\n\tconst test: TestInterface = {\n\t\tonly\t\t: false,\n\t\texcept\t\t: false,\n\t\tfail\t\t: false,\n\t\tassertions\t: [],\n\t\tmessages\t: [],\n\n\t\t...pretest,\n\t}\n\n\t// encapsulate callback\n\tconst rawcallback = test.callback\n\ttest.callback = async () => {\n\t\ttry {\n\t\t\tawait rawcallback(assertions(test))\n\t\t}\n\t\tcatch (e) {\n\t\t\ttest.fail = true\n\n\t\t\ttest.assertions.push({\n\t\t\t\ttype\t: \"test\",\n\t\t\t\tfail\t: true,\n\t\t\t\tmessage\t: \"Exception thrown\",\n\t\t\t\tname\t: (e as any).message,\n\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\tdata\t: [],\n\t\t\t})\n\t\t}\n\t}\n\n\t// add to list\n\ttests.push(test)\n}\n","// Interfaces\nimport ContextInterface from \"../interfaces/context\"\n\nlet context: ContextInterface = {\n\tgroup\t\t: [],\n\n\ttags: [],\n\n\tbeforeAll\t:[],\n\tbeforeEach\t:[],\n\tafterAll\t:[],\n\tafterEach\t:[],\n}\n\nexport const get = () => context\nexport const set = (ctx: ContextInterface) => { context = ctx }\nexport const add = (ctx: Partial<ContextInterface>) => {\n\tcontext = {\n\t\tgroup\t\t: [...context.group\t\t\t, ...(ctx.group || [])],\n\n\t\ttags\t\t: [...context.tags\t\t\t, ...(ctx.tags || [])],\n\n\t\tbeforeAll\t: [...context.beforeAll\t\t, ...(ctx.beforeAll \t|| [])],\n\t\tbeforeEach\t: [...context.beforeEach\t, ...(ctx.beforeEach \t|| [])],\n\t\tafterAll\t: [...context.afterAll\t\t, ...(ctx.afterAll \t\t|| [])],\n\t\tafterEach\t: [...context.afterEach\t\t, ...(ctx.afterEach \t|| [])],\n\t}\n}","\nlet currTest\nexport const getCurr = () => currTest\nexport const setCurr = (curr) => currTest = curr","// Utils\nimport { getCurr } from \"../utils/curr\"\n\nexport default function cache (arg1: string | any, arg2?: any) {\n\tif (!getCurr()) throw new Error(\"Trying to use cache outside of a test context\")\n\n\tgetCurr().messages = [...(getCurr().messages || []), [ arg2 ? arg2:arg1, arg2 ? arg1:undefined ]]\n}","// Utils\nimport * as GroupQueue \t\t\t\t\tfrom \"../utils/group\"\nimport * as TestQueue \t\t\t\t\tfrom \"../utils/test\"\nimport * as ContextQueue \t\t\t\tfrom \"../utils/context\"\nimport { getStackTrace, isArrayEquals } from \"../utils/general\"\nimport { setCurr } \t\t\t\t\t\tfrom \"../utils/curr\"\n\n// Interfaces\nimport ContextInterface \t\tfrom \"../interfaces/context\"\nimport GroupAuxiliaryInterface \tfrom \"../interfaces/groupAuxiliary\"\nimport TestInterface \t\t\tfrom \"../interfaces/testQueue\"\nimport ContextErrorInterface \tfrom \"../interfaces/contextError\"\nimport RunSettings \t\t\t\tfrom \"../interfaces/runSettings\"\n\n// Modules\nimport cache from \"./cache\"\n\nexport default async function run (settings?: RunSettings) {\n\t// Setup enviromnent test\n\tprocess.env.testing = \"true\"\n\n\t// -------------------------------------------------\n\t// Run all groups\n\t// -------------------------------------------------\n\n\tfor (let groups: {ctx: ContextInterface; cb: (aux: GroupAuxiliaryInterface) => void}[] = GroupQueue.get(); groups.length > 0; groups = GroupQueue.get()) {\n\t\tGroupQueue.clear()\n\n\t\tawait Promise.all(groups.map((group) => {\n\t\t\tContextQueue.set(group.ctx)\n\t\t\treturn group.cb({} as any)\n\t\t}))\n\t}\n\n\t// -------------------------------------------------\n\t// Filter\n\t// -------------------------------------------------\n\n\tconst tests = TestQueue.get(settings?.tags || [], !settings?.forceAll)\n\tconst contextFails = [] as ContextErrorInterface[]\n\n\t// -------------------------------------------------\n\t// Run tests\n\t// -------------------------------------------------\n\n\t// set console log to cache it inside as default message\n\tconst defaultLog = console.log\n\tconsole.log = cache\n\n\tconst states = [ \"─\", \"\\\\\", \"|\", \"/\" ]\n\tlet testsrun = 0\n\tlet laststep = 0\n\n\tconst waitProcess = setInterval(() => {\n\t\tif (settings?.spinner !== false) {\n\t\t\tconsole.clear()\n\t\t\tdefaultLog(`\\n ${states[laststep]} (${testsrun}/${tests.length}) Running tests`)\n\n\t\t\tif (laststep + 2 > states.length) laststep = 0\n\t\t\telse laststep++\n\t\t}\n\t}, 250)\n\n\t// -------------------------------------------------\n\t// Run tests\n\t// -------------------------------------------------\n\n\tlet lastcontext\t: string[] = []\n\tlet lasttest\t: TestInterface = {} as TestInterface\n\n\tconst processStart = process.hrtime()\n\n\tfor (let i = 0; i < tests.length; i++) {\n\t\tconst test = tests[i]\n\t\tsetCurr(test)\n\n\t\t// check context for beforeAll\n\t\tif (!isArrayEquals(lastcontext, test.group)) {\n\t\t\ttry {\n\t\t\t\tawait Promise.all(test.beforeAll.map( i => i()))\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tlet ctx = contextFails.find(i => isArrayEquals(i.group, test.group))\n\n\t\t\t\tif (!ctx) {\n\t\t\t\t\tcontextFails.push({\n\t\t\t\t\t\tgroup: test.group,\n\t\t\t\t\t\tfails: [],\n\t\t\t\t\t})\n\n\t\t\t\t\tctx = contextFails[contextFails.length - 1]\n\t\t\t\t}\n\n\t\t\t\tctx.fails.push({\n\t\t\t\t\ttitle\t: (e as any).message,\n\t\t\t\t\ttype\t: \"beforeAll\",\n\t\t\t\t\tmessage\t: \"An error has occured while running beforeAll callback\",\n\t\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\t\tdata\t: [],\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// check context for before each\n\t\ttry {\n\t\t\tawait Promise.all(test.beforeEach.map(i => i()))\n\t\t}\n\t\tcatch (e) {\n\t\t\ttest.assertions.push({\n\t\t\t\ttype\t: \"beforeEach\",\n\t\t\t\tmessage\t: \"An error has occured while running beforeEach callback\",\n\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\tfail\t: true,\n\t\t\t\tdata\t: [],\n\t\t\t})\n\n\t\t\tlet ctx = contextFails.find(i => isArrayEquals(i.group, test.group))\n\n\t\t\tif (!ctx) {\n\t\t\t\tcontextFails.push({\n\t\t\t\t\tgroup: test.group,\n\t\t\t\t\tfails: [],\n\t\t\t\t})\n\n\t\t\t\tctx = contextFails[contextFails.length - 1]\n\t\t\t}\n\n\t\t\tctx.fails.push({\n\t\t\t\ttitle\t: (e as any).message,\n\t\t\t\ttype\t: \"beforeEach\",\n\t\t\t\tmessage\t: \"An error has occured while running beforeEach callback\",\n\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\tdata\t: [],\n\t\t\t})\n\t\t}\n\n\t\t// update context\n\t\tlastcontext = test.group\n\t\tlasttest \t= test\n\t\ttestsrun++\n\n\t\t// run test\n\t\ttry {\n\t\t\tawait new Promise((resolve, reject) => (async () => {\n\t\t\t\t// timer for timeout\n\t\t\t\tconst timer = setTimeout(() => { reject(\"\") }, test.timeout || settings?.timeout || 2000)\n\n\t\t\t\t// test to run\n\t\t\t\tawait (test as unknown as {callback: () => void}).callback()\n\t\t\t\tclearTimeout(timer)\n\t\t\t\tresolve(true)\n\t\t\t})())\n\n\t\t\t// run any async assertions\n\t\t\tawait Promise.all(test.assertions.filter(t => t.async).map(t => t.async))\n\t\t}\n\t\tcatch (e) {\n\t\t\ttest.assertions.push({\n\t\t\t\ttype\t: \"timeout\",\n\t\t\t\tmessage\t: \"Timeout\",\n\t\t\t\tname\t: \"Your test has thrown an timeout after it has been unnresponsive for 2 seconds, you can change this time by changing the run settings timeout or changing the test timeout\",\n\t\t\t\tstack\t: \"\",\n\t\t\t\tfail\t: true,\n\t\t\t\tdata\t: [],\n\t\t\t})\n\t\t}\n\n\t\t// check context for after each\n\t\ttry {\n\t\t\tawait Promise.all(test.afterEach.map(i => i()))\n\t\t}\n\t\tcatch (e) {\n\t\t\ttest.assertions.push({\n\t\t\t\ttype\t: \"afterEach\",\n\t\t\t\tmessage\t: \"An error has occured while running afterEach callback\",\n\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\tfail\t: true,\n\t\t\t\tdata\t: [],\n\t\t\t})\n\n\t\t\tlet ctx = contextFails.find(i => isArrayEquals(i.group, test.group))\n\n\t\t\tif (!ctx) {\n\t\t\t\tcontextFails.push({\n\t\t\t\t\tgroup: test.group,\n\t\t\t\t\tfails: [],\n\t\t\t\t})\n\n\t\t\t\tctx = contextFails[contextFails.length - 1]\n\t\t\t}\n\n\t\t\tctx.fails.push({\n\t\t\t\ttitle\t: (e as any).message,\n\t\t\t\ttype\t: \"afterEach\",\n\t\t\t\tmessage\t: \"An error has occured while running afterEach callback\",\n\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\tdata\t: [],\n\t\t\t})\n\t\t}\n\t}\n\n\t// Return default console log to it's original state\n\tconsole.log = defaultLog\n\n\t// check context for after All\n\tif (lasttest) {\n\t\ttry {\n\t\t\tif (lasttest.afterAll) await Promise.all(lasttest.afterAll.map( i => i()))\n\t\t}\n\t\tcatch (e) {\n\t\t\tlet ctx = contextFails.find(i => isArrayEquals(i.group, lasttest.group))\n\n\t\t\tif (!ctx) {\n\t\t\t\tcontextFails.push({\n\t\t\t\t\tgroup: lasttest.group,\n\t\t\t\t\tfails: [],\n\t\t\t\t})\n\n\t\t\t\tctx = contextFails[contextFails.length - 1]\n\t\t\t}\n\n\t\t\tctx.fails.push({\n\t\t\t\ttitle\t: (e as any).message,\n\t\t\t\ttype\t: \"afterAll\",\n\t\t\t\tmessage\t: \"An error has occured while running afterAll callback\",\n\t\t\t\tstack\t: getStackTrace(1, e),\n\t\t\t\tdata\t: [],\n\t\t\t})\n\t\t}\n\t}\n\tconst processEnd = process.hrtime(processStart)\n\tprocess.env.testing = \"false\"\n\tclearInterval(waitProcess)\n\tif (settings?.spinner !== false) {\n\t\tconsole.clear()\n\t}\n\n\t// Test finished, booting down env\n\tprocess.env.testing = \"false\"\n\n\treturn [tests, contextFails, processEnd] as [TestInterface[], ContextErrorInterface[], [number, number]]\n}","// Interfaces\nimport { ExpectAssertionInterface } from \"../interfaces/expect\"\nimport ExtraOptionsInterface \tfrom \"../interfaces/extraOptions\"\n\n// Utils\nimport * as Context from \"../utils/context\"\nimport * as Queue \tfrom \"../utils/test\"\n\nexport default function test (title: string, callback: (expect: ExpectAssertionInterface) => Promise<void> | void) {\n\tconst context = Context.get()\n\n\tQueue.add({\n\t\t...context,\n\t\tid: `${context.group.join(\"/\")}/${title}`,\n\t\ttitle,\n\t\tcallback,\n\t})\n\n\tconst extra = {\n\t\ttag: (tag: string | string[]) => {\n\t\t\tQueue.append({\n\t\t\t\ttags: Array.isArray(tag) ? tag: [tag],\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t\ttimeout: (time: number) => {\n\t\t\tQueue.append({\n\t\t\t\ttimeout: time,\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t} as ExtraOptionsInterface\n\n\treturn extra\n}","// Packages\nimport * as glob from \"glob\"\nimport { join } from \"path\"\n\nconst findMethod = async (regex?: string) => {\n\tawait new Promise(r => {\n\t\tglob.glob(regex || \"./**/*.{test,tests}.{ts,js}\", {\n\t\t\tcwd\t\t: process.cwd(),\n\t\t\tnodir\t: true,\n\t\t\tignore\t: [ \"./node_modules/**/*\" ],\n\t\t}, (_e, matches) => {\n\t\t\tPromise.all(matches.map(async file => import(join(process.cwd(), file)))).then(r)\n\t\t})\n\t})\n}\n\nexport default findMethod","// Interfaces\nimport GroupAuxiliaryInterface \tfrom \"../interfaces/groupAuxiliary\"\nimport ExtraOptionsInterface \tfrom \"../interfaces/extraOptions\"\n\n// Utils\nimport * as GroupQueue \t\tfrom \"../utils/group\"\nimport * as ContextQueue \tfrom \"../utils/context\"\n\nexport default function group (title: string, callback: (group: GroupAuxiliaryInterface) => void) {\n\tconst context = {...ContextQueue.get()}\n\n\tcontext.group = [...context.group, title]\n\n\tGroupQueue.add({ctx: context, cb: async () => callback({\n\t\tbeforeAll\t: (cb) => ContextQueue.add({beforeAll:[cb]}),\n\t\tbeforeEach\t: (cb) => ContextQueue.add({beforeEach:[cb]}),\n\t\tafterAll\t: (cb) => ContextQueue.add({afterAll:[cb]}),\n\t\tafterEach\t: (cb) => ContextQueue.add({afterEach:[cb]}),\n\t})})\n\n\tconst extra = {\n\t\ttag: (tag: string | string[]) => {\n\t\t\tGroupQueue.append({\n\t\t\t\ttags: Array.isArray(tag) ? tag: [tag],\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t} as ExtraOptionsInterface\n\n\treturn extra\n}","// Interfaces\nimport { ExpectAssertionInterface } from \"../interfaces/expect\"\nimport ExtraOptionsInterface \t\tfrom \"../interfaces/extraOptions\"\n\n// Utils\nimport * as Context from \"../utils/context\"\nimport * as Queue \tfrom \"../utils/test\"\n\nexport default function only (title: string, callback: (expect: ExpectAssertionInterface) => Promise<void> | void) {\n\tconst context = Context.get()\n\n\tQueue.add({\n\t\t...context,\n\t\tid: `${context.group.join(\"/\")}/${title}`,\n\t\ttitle,\n\t\tonly: true,\n\t\tcallback,\n\t})\n\n\tconst extra = {\n\t\ttag: (tag: string | string[]) => {\n\t\t\tQueue.append({\n\t\t\t\ttags: Array.isArray(tag) ? tag: [tag],\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t\ttimeout: (time: number) => {\n\t\t\tQueue.append({\n\t\t\t\ttimeout: time,\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t} as ExtraOptionsInterface\n\n\treturn extra\n}","// Interfaces\nimport { ExpectAssertionInterface } from \"../interfaces/expect\"\n\n// Utils\nimport * as Context from \"../utils/context\"\nimport * as Queue \tfrom \"../utils/test\"\n\nexport default function except (title: string, callback: (_: ExpectAssertionInterface) => Promise<void> | void) {\n\tconst context = Context.get()\n\n\tQueue.add({\n\t\t...context,\n\t\tid: `${context.group.join(\"/\")}/${title}`,\n\t\ttitle,\n\t\texcept: true,\n\t\tcallback,\n\t})\n\n\tconst extra = {\n\t\ttag: (tag: string | string[]) => {\n\t\t\tQueue.append({\n\t\t\t\ttags: Array.isArray(tag) ? tag: [tag],\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t\ttimeout: (time: number) => {\n\t\t\tQueue.append({\n\t\t\t\ttimeout: time,\n\t\t\t})\n\n\t\t\treturn extra\n\t\t},\n\t}\n\n\treturn extra\n}","// Interfaces\nimport * as ContextQueue \tfrom \"../utils/context\"\nimport * as GroupQueue \t\tfrom \"../utils/group\"\n\nexport default function tag (tag: string | string[], callback: () => void) {\n\tconst context = ContextQueue.get()\n\n\tGroupQueue.add({\n\t\tctx: {\n\t\t\t...context,\n\t\t\ttags: Array.isArray(tag) ? tag : [tag],\n\t\t},\n\t\tcb: callback,\n\t})\n\n\tcallback()\n}","// Utils\nimport { isArrayEquals, repeatString } \tfrom \"../utils/general\"\n\n// Interfaces\nimport TestInterface \t\t\tfrom \"../interfaces/testQueue\"\nimport ContextErrorInterface \tfrom \"../interfaces/contextError\"\n\nexport default async function run (tests: TestInterface[], contextErrors: ContextErrorInterface[] = [], elapsedTime: [number, number] = [0,0]) {\n\tconsole.clear()\n\tconsole.log()\n\n\t// -------------------------------------------------\n\t// Display tests\n\t// -------------------------------------------------\n\n\tconsole.log(\"===============================\")\n\tconsole.log(\" Tests ran\")\n\tconsole.log(\"===============================\")\n\tconsole.log()\n\n\tif (tests.length === 0) {\n\t\tconsole.log(\"no test to run\")\n\t}\n\telse {\n\t\tlet lastgroup = [] as string[]\n\n\t\ttests.forEach(test => {\n\t\t\t// print test group\n\t\t\tif (!isArrayEquals(test.group, lastgroup)) {\n\t\t\t\tconsole.log()\n\t\t\t\ttest.group.forEach((item, index) => {\n\t\t\t\t\tif (lastgroup[index] !== item) {\n\t\t\t\t\t\tconst fails = (contextErrors.find(i => isArrayEquals(i.group, test.group))?.fails || []).map(i => `\\x1b[31m${i.type}\\x1b[37m`).join(\",\")\n\t\t\t\t\t\tconsole.log(`${repeatString(\"    \", index)} ${item}${fails ? ` (${fails})`:\"\"}`)\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tlastgroup = test.group\n\t\t\t}\n\n\t\t\t// prepare assertions print\n\t\t\tconst fail = !!test.assertions.find(a => a.fail)\n\t\t\tconst assertions = fail ? test.assertions.map(i => `${i.fail ? \"\\x1b[31m\":\"\\x1b[32m\"}${i.type}\\x1b[37m`).join(\", \") : `\\x1b[32m${test.assertions.length} assertions\\x1b[37m`\n\t\t\tconsole.log(`${repeatString(\"    \", lastgroup.length - 1)} ${lastgroup.length !== 0 ? \" \":\"\"}${fail ? \"\\x1b[31mx\":\"\\x1b[32m√\\x1b[37m\"}\\x1b[37m - ${test.title} (${assertions ? assertions: \"no assertions made\"})`)\n\t\t})\n\t}\n\n\t// -------------------------------------------------\n\t// Display errors\n\t// -------------------------------------------------\n\n\tconst [ total, success ] = [tests.length, tests.filter(test => !test.assertions.find(a => a.fail)).length]\n\n\tif (total !== success) {\n\t\tconsole.log()\n\t\tconsole.log(\"===============================\")\n\t\tconsole.log(\" Tests failed\")\n\t\tconsole.log(\"===============================\")\n\t\tconsole.log()\n\n\t\ttests.forEach(test => {\n\t\t\ttest.assertions.forEach(assertion => {\n\t\t\t\tif (assertion.fail) {\n\t\t\t\t\tconsole.log(` \\x1b[31mx\\x1b[37m - ${test.group.join(\" \\x1b[36m>\\x1b[37m \")}${test.group.length > 0 ? \"\\x1b[36m >\\x1b[37m \":\"\"}${test.title}`)\n\t\t\t\t\tconsole.log(\"\\x1b[31m\")\n\t\t\t\t\tconsole.log(`\\x1b[31m${assertion.message}\\n`)\n\t\t\t\t\tif (assertion.name) console.log(`    ${assertion.name}`)\n\t\t\t\t\tconsole.log(`${assertion.stack}`)\n\t\t\t\t\tconsole.log(\"\\x1b[37m\")\n\t\t\t\t\tassertion.data.forEach((data, index) => console.log(`- ${data[1] !== undefined ? data[0] : index} `, data[1] !== undefined ? data[1] : data[0]))\n\t\t\t\t\tif (assertion.data.length > 0) console.log()\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\tif (contextErrors.length) {\n\t\tconsole.log()\n\n\t\tcontextErrors.forEach((group) => {\n\t\t\tgroup.fails.forEach((fail) => {\n\t\t\t\tconsole.log(` \\x1b[31mx\\x1b[37m - ${group.group?.join(\" \\x1b[36m>\\x1b[37m \")}`)\n\t\t\t\tconsole.log(\"\\x1b[31m\")\n\t\t\t\tconsole.log(fail.message)\n\t\t\t\tfail.data.forEach(data => console.log(data))\n\t\t\t\tconsole.log()\n\t\t\t\tconsole.log(fail.title)\n\t\t\t\tconsole.log(` ${fail.stack}`)\n\t\t\t\tconsole.log(\"\\x1b[37m\")\n\t\t\t})\n\t\t})\n\t}\n\n\t// -------------------------------------------------\n\t// Display messages\n\t// -------------------------------------------------\n\n\tif (tests.find(i => i.messages.length > 0)) {\n\t\tconsole.log()\n\t\tconsole.log(\"===============================\")\n\t\tconsole.log(\" Tests messages\")\n\t\tconsole.log(\"===============================\")\n\t\tconsole.log()\n\n\t\ttests.forEach(test => {\n\t\t\tif (test.messages.length > 0) {\n\t\t\t\ttest.messages.forEach(message => {\n\t\t\t\t\tconsole.log(`• ${test.group.join(\" \\x1b[36m>\\x1b[37m \")} ${test.group.length > 0 ? \"\\x1b[36m>\\x1b[37m \":\"\"}${test.title}`)\n\t\t\t\t\tif (message[1]) console.log(`message: ${message[1]}`)\n\t\t\t\t\tconsole.log(message[0])\n\t\t\t\t\tconsole.log()\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\t// -------------------------------------------------\n\t// Display statistics\n\t// -------------------------------------------------\n\n\tconst totalMs = Math.ceil((elapsedTime[0]* 1000000000 + elapsedTime[1]) / 1000000)\n\tconst minutes = Math.floor(totalMs / 60000)\n\tconst seconds = Math.floor(totalMs / 1000) - minutes * 60\n\tconst milisec = totalMs % 1000\n\n\tconsole.log()\n\tconsole.log(\"===============================\")\n\tconsole.log(\" Tests results\")\n\tconsole.log(\"===============================\")\n\tconsole.log()\n\tconsole.log(` Total tests\\t\\t: ${total}`)\n\tconsole.log(` Successful tests\\t: ${success}`)\n\tconsole.log(` Total time elapsed\\t: ${minutes ? `${minutes}m `:\"\"}${seconds ? `${seconds}s `:\"\"}${milisec}ms`)\n\tconsole.log()\n\n\tif (total !== success) process.exit(1)\n}","// Modules\nimport run \t\tfrom \"./run\"\nimport print \tfrom \"./print\"\n\n// Interfaces\nimport RunSettings from \"../interfaces/runSettings\"\n\nexport default async function runAndPrint(settings?: RunSettings) {\n\tconst result = await run(settings)\n\n\tif (settings?.spinner !== false) {\n\t\tawait print(...result)\n\t}\n}","// Modules\r\nimport runMethod \t\t\tfrom \"./modules/run\"\r\nimport testMethod\t\t\tfrom \"./modules/test\"\r\nimport findMethod \t\t\tfrom \"./modules/find\"\r\nimport cacheMethod \t\t\tfrom \"./modules/cache\"\r\nimport groupMethod \t\t\tfrom \"./modules/group\"\r\nimport onlyMethod \t\t\tfrom \"./modules/only\"\r\nimport exceptMethod \t\tfrom \"./modules/except\"\r\nimport tagMethod \t\t\tfrom \"./modules/tag\"\r\nimport printMethod \t\t\tfrom \"./modules/print\"\r\nimport runAndPrintMethod \tfrom \"./modules/runAndPrint\"\r\n\r\n// Interfaces\r\nimport TestModuleInterface from \"./interfaces/testModule\"\r\n\r\n// build\r\nconst test \t\t\t= testMethod as TestModuleInterface\r\ntest.run \t\t\t= runMethod\r\ntest.find\t\t\t= findMethod\r\ntest.group \t\t\t= groupMethod\r\ntest.cache \t\t\t= cacheMethod\r\ntest.only \t\t\t= onlyMethod\r\ntest.except\t\t\t= exceptMethod\r\ntest.tag\t\t\t= tagMethod\r\ntest.print\t\t\t= printMethod\r\ntest.runAndPrint\t= runAndPrintMethod\r\n\r\n// export\r\nexport default test"],"names":["glob2"],"mappings":"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"}