{"version":3,"file":"index.js","sources":["../src/classes/InvalidRuleException.ts","../src/rules/validations/array/index.ts","../src/rules/validations/confirmed/index.ts","../src/rules/validations/email/index.ts","../src/rules/validations/uuid/index.ts","../src/rules/validations/object/index.ts","../src/rules/validations/required/index.ts","../src/rules/validations/string/index.ts","../src/rules/validations/number/index.ts","../src/rules/validations/in/index.ts","../src/rules/validations/notIn/index.ts","../src/rules/validations/integer/index.ts","../src/rules/validations/truthy/index.ts","../src/rules/validations/min/index.ts","../src/rules/validations/max/index.ts","../src/rules/validations/regex/index.ts","../src/rules/validations/date/index.ts","../src/rules/index.ts","../src/modules/validator/index.ts","../src/index.ts"],"sourcesContent":["// Packages\nimport { CustomException } from \"@acai/utils\"\n\nexport default class InvalidRuleException extends CustomException {\n\tshouldReport = true;\n\n\tpublic constructor (message: string, data?: any) {\n\t\tsuper(\"invalidValidationRule\", message, data)\n\t}\n\n\tpublic report () {\n\t\tconsole.log(this.message)\n\t}\n}","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({ value }) \t=> Array.isArray(value),\r\n\tonError\t\t: ({ key }) \t=> `${key} is not an array`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value, key, fields}) \t=> fields[`${key}_confirmation`] && fields[`${key}_confirmation`] === value,\r\n\tonError\t\t: ({value, key, fields}) \t=> {\r\n\t\tif (!fields[`${key}_confirmation`]) {\r\n\t\t\treturn `${key} is not confirmed`\r\n\t\t}\r\n\t\tif (fields[`${key}_confirmation`] !== value) {\r\n\t\t\treturn `${key} confirmation does not match`\r\n\t\t}\r\n\r\n\t\treturn undefined\r\n\t},\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value}) => !!((typeof value === \"string\") && (value as string).match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/)),\r\n\tonError\t\t: ({key}) \t=> `${key} is not an email`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value}) => !!((typeof value === \"string\") && (value as string).match(/\\b[0-9a-f]{8}\\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\\b[0-9a-f]{12}\\b/)),\r\n\tonError\t\t: ({key}) \t=> `${key} is not a valid uuid`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value}) => typeof value === \"object\",\r\n\tonError\t\t: ({key}) \t=> `${key} is not an object`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value}) => !!value,\r\n\tonError\t\t: ({key}) \t=> `${key} is required`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value}) => typeof value === \"string\",\r\n\tonError\t\t: ({key}) \t=> `${key} is not a string`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate : ({value, args}) => {\r\n\t\tif (args && args.includes(\"force\")) return !isNaN(value as number)\r\n\r\n\t\treturn typeof value === \"number\"\r\n\t},\r\n\tonMask\t: ({value}) => parseFloat(value as string),\r\n\tonError : ({key}) => `${key} is not a number`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\n// Classes\r\nimport InvalidRuleException from \"../../../classes/InvalidRuleException\"\r\n\r\nconst types = {\r\n\tarray\t: (value: unknown, args: string[]) => Array.isArray(value) \t\t&& args.find(a => (value as string[]).find(v => v === a)),\r\n\tstring\t: (value: unknown, args: string[]) => typeof value === \"string\" && args.find(a => a === value),\r\n\tobject\t: (value: unknown, args: string[]) => typeof value === \"object\" && args.find(a => value && Object.keys(value).find(v => v === a)),\r\n\tnumber\t: (value: unknown, args: string[]) => typeof value === \"number\" && args.find(a => a === `${value}`),\r\n}\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({ value, args, rules, key }) => {\r\n\t\tif (!args || args.length === 0) {\r\n\t\t\tthrow new InvalidRuleException(`Rule 'in' for field ${key} has invalid number of arguments`, {value, args, rules, key})\r\n\t\t}\r\n\r\n\t\tif (rules.includes(\"array\"))\r\n\t\t\treturn types.array(value, args)\r\n\t\telse if (rules.includes(\"string\"))\r\n\t\t\treturn types.string(value, args)\r\n\t\telse if (rules.includes(\"object\"))\r\n\t\t\treturn types.object(value, args)\r\n\t\telse if (rules.includes(\"number\"))\r\n\t\t\treturn types.number(value, args)\r\n\r\n\t\treturn false\r\n\t},\r\n\tonError\t\t: ({ rules, value, key, args }) => {\r\n\t\tif (rules.includes(\"array\")) {\r\n\t\t\tif (!Array.isArray(value)) return `${key} value is not an array`\r\n\r\n\t\t\treturn `${key} does not include one of the values: ${(args || []).join(\", \")}`\r\n\t\t}\r\n\t\tif (rules.includes(\"string\")) {\r\n\t\t\tif (typeof value !== \"string\") return `${key} value is not a string`\r\n\r\n\t\t\treturn `${key} does not include one of the values: ${(args || []).join(\", \")}`\r\n\t\t}\r\n\t\tif (rules.includes(\"object\")) {\r\n\t\t\tif (typeof value !== \"object\") return `${key} value is not a object`\r\n\r\n\t\t\treturn `${key} does not include one of the values: ${(args || []).join(\", \")}`\r\n\t\t}\r\n\t\tif (rules.includes(\"number\")) {\r\n\t\t\tif (typeof value !== \"number\") return `${key} value is not a number`\r\n\r\n\t\t\treturn `${key} does not include one of the values: ${(args || []).join(\", \")}`\r\n\t\t}\r\n\r\n\t\treturn undefined\r\n\t},\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\n// Classes\r\nimport InvalidRuleException from \"../../../classes/InvalidRuleException\"\r\n\r\nconst types = {\r\n\tarray\t: (value: unknown, args: string[]) => Array.isArray(value) \t\t&& args.filter(a => (value as string[]).find(v => v.match(a))).length === 0,\r\n\tstring\t: (value: unknown, args: string[]) => typeof value === \"string\" && args.filter(a => value.match(a)).length === 0,\r\n\tobject\t: (value: unknown, args: string[]) => typeof value === \"object\" && value && args.filter(a => Object.keys(value).find(v => v.match(a))).length === 0,\r\n\tnumber\t: (value: unknown, args: string[]) => typeof value === \"number\" && args.filter(a => `${value}`.match(a)).length === 0,\r\n}\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({ value, args, rules, key }) => {\r\n\t\tif (!args || args.length === 0) {\r\n\t\t\tthrow new InvalidRuleException(`Rule 'notIn' for field ${key} has invalid number of arguments`, {value, args, rules, key})\r\n\t\t}\r\n\r\n\t\tif (rules.includes(\"array\"))\r\n\t\t\treturn types.array(value, args)\r\n\t\telse if (rules.includes(\"string\"))\r\n\t\t\treturn types.string(value, args)\r\n\t\telse if (rules.includes(\"object\"))\r\n\t\t\treturn types.object(value, args)\r\n\t\telse if (rules.includes(\"number\"))\r\n\t\t\treturn types.number(value, args)\r\n\r\n\t\treturn false\r\n\t},\r\n\tonError\t\t: ({ rules, value, key, args }) => {\r\n\t\tif (rules.includes(\"array\")) {\r\n\t\t\tif (!Array.isArray(value)) return `${key} value is not an array`\r\n\r\n\t\t\treturn `${key} should not include values: ${(args || []).filter(a => (value as string[]).find(v => v.match(a))).join(\", \")}`\r\n\t\t}\r\n\t\tif (rules.includes(\"string\")) {\r\n\t\t\tif (typeof value !== \"string\") return `${key} value is not a string`\r\n\r\n\t\t\treturn `${key} should not include values: ${(args || []).filter(a => value.match(a)).join(\", \")}`\r\n\t\t}\r\n\t\tif (rules.includes(\"object\")) {\r\n\t\t\tif (typeof value !== \"object\") return `${key} value is not a object`\r\n\r\n\t\t\treturn `${key} should not include values: ${(args || []).filter(a => Object.keys((value as string[])).find(v => v.match(a))).join(\", \")}`\r\n\t\t}\r\n\t\tif (rules.includes(\"number\")) {\r\n\t\t\tif (typeof value !== \"number\") return `${key} value is not a number`\r\n\r\n\t\t\treturn `${key} should not include values: ${(args || []).filter(a => `${value}`.match(a)).join(\", \")}`\r\n\t\t}\r\n\r\n\t\treturn undefined\r\n\t},\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate : ({value, args}) => {\r\n\t\tif ((args && args.includes(\"force\") && !isNaN(value as number)) || typeof value === \"number\") {\r\n\t\t\treturn parseFloat(value as string) === parseInt(value as string)\r\n\t\t}\r\n\r\n\t\treturn false\r\n\t},\r\n\tonMask\t: ({value}) => parseFloat(value as string),\r\n\tonError : ({key}) => `${key} is not an integer`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value}) => !!value,\r\n\tonError\t\t: ({key}) \t=> `${key} is not truthy`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\n// Classes\r\nimport InvalidRuleException from \"../../../classes/InvalidRuleException\"\r\n\r\nconst types = {\r\n\tarray\t: (value: unknown, args: string[]) => Array.isArray(value) \t\t&& value.length >= parseInt(args[0]),\r\n\tobject\t: (value: unknown, args: string[]) => typeof value === \"object\"\t&& value && Object.keys(value).length >= parseInt(args[0]),\r\n\tstring\t: (value: unknown, args: string[]) => typeof value === \"string\" && value.length >= parseInt(args[0]),\r\n\tnumber\t: (value: unknown, args: string[]) => typeof value === \"number\" && value >= parseInt(args[0]),\r\n}\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({ value, args, rules, key }) => {\r\n\t\tif (!args || args.length !== 1) {\r\n\t\t\tthrow new InvalidRuleException(`Rule 'min' for field ${key} has invalid number of arguments`, {value, args, rules, key})\r\n\t\t}\r\n\r\n\t\tif (rules.includes(\"array\"))\r\n\t\t\treturn types.array(value, args)\r\n\t\telse if (rules.includes(\"string\"))\r\n\t\t\treturn types.string(value, args)\r\n\t\telse if (rules.includes(\"object\"))\r\n\t\t\treturn types.object(value, args)\r\n\t\telse if (rules.includes(\"number\"))\r\n\t\t\treturn types.number(value, args)\r\n\r\n\t\treturn false\r\n\t},\r\n\tonError\t\t: ({ rules, value, key, args }) => {\r\n\t\tif (rules.includes(\"array\")) {\r\n\t\t\tif (!Array.isArray(value)) return `${key} value is not an array`\r\n\r\n\t\t\treturn `${key} has less elements than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\t\tif (rules.includes(\"string\")) {\r\n\t\t\tif (typeof value !== \"string\") return `${key} value is not a string`\r\n\r\n\t\t\treturn `${key} has less characters than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\t\tif (rules.includes(\"object\")) {\r\n\t\t\tif (typeof value !== \"object\") return `${key} value is not a object`\r\n\r\n\t\t\treturn `${key} has less keys than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\t\tif (rules.includes(\"number\")) {\r\n\t\t\tif (typeof value !== \"number\") return `${key} value is not a number`\r\n\r\n\t\t\treturn `${key} is less than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\r\n\t\treturn undefined\r\n\t},\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\n// Classes\r\nimport InvalidRuleException from \"../../../classes/InvalidRuleException\"\r\n\r\nconst types = {\r\n\tarray\t: (value: unknown, args: string[]) => Array.isArray(value) \t\t&& value.length <= parseInt(args[0]),\r\n\tobject\t: (value: unknown, args: string[]) => typeof value === \"object\"\t&& value && Object.keys(value).length <= parseInt(args[0]),\r\n\tstring\t: (value: unknown, args: string[]) => typeof value === \"string\" && value.length <= parseInt(args[0]),\r\n\tnumber\t: (value: unknown, args: string[]) => typeof value === \"number\" && value <= parseInt(args[0]),\r\n}\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({ value, args, rules, key }) => {\r\n\t\tif (!args || args.length !== 1) {\r\n\t\t\tthrow new InvalidRuleException(`Rule 'max' for field ${key} has invalid number of arguments`, {value, args, rules, key})\r\n\t\t}\r\n\r\n\t\tif (rules.includes(\"array\"))\r\n\t\t\treturn types.array(value, args)\r\n\t\telse if (rules.includes(\"string\"))\r\n\t\t\treturn types.string(value, args)\r\n\t\telse if (rules.includes(\"object\"))\r\n\t\t\treturn types.object(value, args)\r\n\t\telse if (rules.includes(\"number\"))\r\n\t\t\treturn types.number(value, args)\r\n\r\n\t\treturn false\r\n\t},\r\n\tonError\t\t: ({ rules, value, key, args }) => {\r\n\t\tif (rules.includes(\"array\")) {\r\n\t\t\tif (!Array.isArray(value)) return `${key} value is not an array`\r\n\r\n\t\t\treturn `${key} has more elements than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\t\tif (rules.includes(\"string\")) {\r\n\t\t\tif (typeof value !== \"string\") return `${key} value is not a string`\r\n\r\n\t\t\treturn `${key} has more characters than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\t\tif (rules.includes(\"object\")) {\r\n\t\t\tif (typeof value !== \"object\") return `${key} value is not a object`\r\n\r\n\t\t\treturn `${key} has more keys than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\t\tif (rules.includes(\"number\")) {\r\n\t\t\tif (typeof value !== \"number\") return `${key} value is not a number`\r\n\r\n\t\t\treturn `${key} is more than the allowed: ${(args || [])[0]}`\r\n\t\t}\r\n\r\n\t\treturn undefined\r\n\t},\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\n// Classes\r\nimport InvalidRuleException from \"../../../classes/InvalidRuleException\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({value, args, rules, key}) => {\r\n\t\tif (typeof value !== \"string\") return false\r\n\r\n\t\tif (!args || args.length !== 1) {\r\n\t\t\tthrow new InvalidRuleException(`Rule 'regex' for field ${key} has invalid number of arguments`, {value, args, rules, key})\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\t\"\".match(new RegExp(args[0]))\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\tthrow new InvalidRuleException(`Rule 'regex' for field ${key} has a invalid regex pattern (${args[0]})`, {value, args, rules, key})\r\n\t\t}\r\n\r\n\t\treturn !!value.match(new RegExp(args[0]))\r\n\t},\r\n\tonError\t\t: ({key}) => `${key} does not passes the regex`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Packages\r\nimport { DateTime } from \"luxon\"\r\n\r\n// Interfaces\r\nimport RuleInterface from \"../../../interfaces/rule\"\r\n\r\nconst rule = {\r\n\t// callbacks\r\n\tonValidate\t: ({ value, args })\t=> {\r\n\t\tif (args && args[0])\r\n\t\t\treturn DateTime.fromFormat(value as string, args[0]).isValid\r\n\r\n\t\treturn DateTime.fromISO(value as string).isValid\r\n\t},\r\n\tonError\t\t: ({ key }) \t=> `${key} is not a valid date`,\r\n} as RuleInterface\r\n\r\nexport default rule","// Interfaces\nimport RuleInterface from \"../interfaces/rule\"\n\n// Validation rules\nimport arrayRule \t\tfrom \"./validations/array\"\nimport confirmedRule \tfrom \"./validations/confirmed\"\nimport emailRule \t\tfrom \"./validations/email\"\nimport uuidRule \t\tfrom \"./validations/uuid\"\nimport objectRule \t\tfrom \"./validations/object\"\nimport requiredRule \tfrom \"./validations/required\"\nimport stringRule \t\tfrom \"./validations/string\"\nimport numberRule \t\tfrom \"./validations/number\"\nimport inRule\t\t\tfrom \"./validations/in\"\nimport notInRule\t\tfrom \"./validations/notIn\"\nimport integerRule\t\tfrom \"./validations/integer\"\nimport truthyRule\t\tfrom \"./validations/truthy\"\nimport minRule\t\t\tfrom \"./validations/min\"\nimport maxRule\t\t\tfrom \"./validations/max\"\nimport regexRule\t\tfrom \"./validations/regex\"\nimport dateRule\t\t\tfrom \"./validations/date\"\n\n// list\nlet ruleList: Record<string, RuleInterface> = {\n\t// general\n\t\"confirmed\"\t: confirmedRule,\n\t\"required\"\t: requiredRule,\n\t\"truthy\"\t: truthyRule,\n\n\t// string\n\t\"email\"\t\t: emailRule,\n\t\"uuid\"\t\t: uuidRule,\n\t\"regex\"\t\t: regexRule,\n\t\"date\"\t\t: dateRule,\n\n\t// composite\n\t\"in\"\t\t: inRule,\n\t\"notIn\"\t\t: notInRule,\n\t\"min\"\t\t: minRule,\n\t\"max\"\t\t: maxRule,\n\n\t// type\n\t\"object\"\t: objectRule,\n\t\"string\"\t: stringRule,\n\t\"array\"\t\t: arrayRule,\n\t\"number\"\t: numberRule,\n\n\t// number\n\t\"float\"\t\t: numberRule,\n\t\"integer\"\t: integerRule,\n\t\"int\"\t\t: integerRule,\n}\n\n// methods\nexport function setRule(name: string, rule: RuleInterface) {\n\truleList[name] = rule\n}\n\nexport function setRules(rules: Record<string, RuleInterface>) {\n\tObject.keys(rules).forEach(name => {\n\t\truleList[name] = rules[name]\n\t})\n}\n\nexport function clearRules() {\n\truleList = {}\n}\n\n// default\nexport default () => ruleList","// Interfaces\r\nimport RuleInterface \t\tfrom \"../../interfaces/rule\"\r\nimport Writable\t\t\t\tfrom \"../../interfaces/writable\"\r\nimport SchemaToTypedSchema \tfrom \"../../interfaces/schemaToTypedSchema\"\r\n\r\n// Exceptions\r\nimport InvalidRuleException from \"../../classes/InvalidRuleException\"\r\n\r\n// Rules\r\nimport ruleList from \"../../rules/index\"\r\n\r\nexport default class Validator<\r\n\tFields extends Record<string, unknown> | undefined = undefined,\r\n\tKeys extends string = keyof ReturnType<InstanceType<typeof Validator>[\"getSchema\"]>,\r\n\tSchema extends Readonly<Record<Keys, readonly string[]>> = ReturnType<InstanceType<typeof Validator>[\"getSchema\"]>,\r\n\tUsageFields extends Record<string, unknown> = Fields extends undefined ? SchemaToTypedSchema<Schema>:Fields\r\n> {\r\n\t// -------------------------------------------------\r\n\t// Properties\r\n\t// -------------------------------------------------\r\n\r\n\t// overwritable\r\n\tpublic throwable = true;\r\n\r\n\t// internal\r\n\tprotected _fields\t: any;\r\n\tprotected _validated: Record<string, unknown> \t= {};\r\n\tprotected _errors\t: Record<string, string[]> \t= {};\r\n\r\n\t// -------------------------------------------------\r\n\t// Main methods\r\n\t// -------------------------------------------------\r\n\r\n\tconstructor (fields: Record<string, any> = {}) {\r\n\t\tthis._fields = fields as any\r\n\t}\r\n\r\n\tpublic static validate<T extends new (...args: any) => any, I = InstanceType<T>>(this: T, fields?: Partial<ConstructorParameters<T>[0]>, overwriteSchemaOrThrow?: Record<string, string[]> | boolean): I {\r\n\t\tconst validator =  new this(fields)\r\n\t\tvalidator.validate(overwriteSchemaOrThrow)\r\n\t\treturn validator as unknown as I\r\n\t}\r\n\r\n\tpublic validate(overwriteSchemaOrThrow: Record<string, string[]> | boolean | undefined = undefined) {\r\n\t\tconst schema = typeof overwriteSchemaOrThrow === \"object\" ? overwriteSchemaOrThrow : this.getSchema()\r\n\r\n\t\tObject.keys(schema).forEach(fieldName => {\r\n\t\t\tlet passes\t\t\t= true\r\n\t\t\tlet fieldValue \t\t= this._fields[fieldName]\r\n\t\t\tconst rulesApplied \t= Array.isArray(schema[fieldName]) ? (schema[fieldName] as string[]):(schema[fieldName] as string).split(\";\")\r\n\t\t\tconst isRequired\t= rulesApplied.find(i => i.split(\":\")[0] === \"required\")\r\n\t\t\tconst rulesNames\t= rulesApplied.map(i => i.split(\":\")[0])\r\n\r\n\t\t\tif (!(fieldValue === undefined && !isRequired)) {\r\n\t\t\t\tfor (let i = 0; i < rulesApplied.length; i++) {\r\n\t\t\t\t\tconst [name, ...preargs] \t= rulesApplied[i].split(\":\")\r\n\t\t\t\t\tconst args\t\t\t\t\t= (preargs.join(\":\") || \"\").split(\",\")\r\n\t\t\t\t\tconst rule \t\t\t\t\t= this.rules[name]\r\n\r\n\t\t\t\t\tif (!rule) {\r\n\t\t\t\t\t\tthrow new InvalidRuleException(`Rule ${name} on validator ${this.constructor.name} doesn't exist`)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// validation failed\r\n\t\t\t\t\tif (rule.onValidate && !rule.onValidate({value: fieldValue, key: fieldName, fields: this._fields, args, rules: rulesNames})) {\r\n\t\t\t\t\t\tpasses = false\r\n\t\t\t\t\t\tconst error = rule.onError && rule.onError({value: fieldValue, key: fieldName, fields: this._fields, args, rules: rulesNames}) || `${name} failed validation`\r\n\r\n\t\t\t\t\t\t// instance it\r\n\t\t\t\t\t\tif (!this._errors[fieldName]) this._errors[fieldName] = []\r\n\r\n\t\t\t\t\t\t// push\r\n\t\t\t\t\t\tif (Array.isArray(error))\r\n\t\t\t\t\t\t\terror.forEach(i => this._errors[fieldName].push(i))\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthis._errors[fieldName].push(error)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// validation successful\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tfieldValue = rule.onMask ? rule.onMask({value: fieldValue, key: fieldName, fields: this._fields, args, rules: rulesNames}):fieldValue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// validation successful\r\n\t\t\t\tif (!this._errors[fieldName]) {\r\n\t\t\t\t\tthis._validated[fieldName] = fieldValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (passes && !this._validated[fieldName]) this._validated[fieldName] = fieldValue\r\n\t\t})\r\n\r\n\t\t// check if should throw\r\n\t\tif (overwriteSchemaOrThrow !== false && this.throwable && Object.keys(this._errors).length > 0) {\r\n\t\t\tconst error \t\t= new Error(\"Validation error\") as Error & {type: string; data?: Record<string, unknown>; shouldReport?: boolean}\r\n\t\t\terror.type \t\t\t= \"validation\"\r\n\t\t\terror.data\t\t\t= this.printErrors()\r\n\t\t\terror.shouldReport \t= false\r\n\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\t// -------------------------------------------------\r\n\t// Overwritable methods\r\n\t// -------------------------------------------------\r\n\r\n\tpublic getSchema(): Readonly<Record<Keys, readonly string[]>> {\r\n\t\tthrow new Error(\"Schema not implemented\")\r\n\t}\r\n\r\n\tpublic printErrors () {\r\n\t\tif (Object.keys(this._errors).length === 0) return undefined\r\n\r\n\t\treturn {\r\n\t\t\terrors: this._errors,\r\n\t\t}\r\n\t}\r\n\r\n\t// -------------------------------------------------\r\n\t// Get methods\r\n\t// -------------------------------------------------\r\n\r\n\tpublic get rules (): Record<string, RuleInterface> {\r\n\t\treturn ruleList()\r\n\t}\r\n\r\n\tpublic get validated (): Writable<Fields extends undefined ? SchemaToTypedSchema<ReturnType<this[\"getSchema\"]>>:Fields> {\r\n\t\treturn this._validated as any\r\n\t}\r\n\r\n\tpublic get errors () {\r\n\t\treturn this.printErrors() as any as {errors: Record<keyof UsageFields, string[]>} | undefined\r\n\t}\r\n\r\n\tpublic get fields () {\r\n\t\treturn this._fields as Fields extends undefined ? Record<(keyof ReturnType<this[\"getSchema\"]>) & string, any>:Fields\r\n\t}\r\n}","/**\r\n* Copyright (c) 2020 The Nuinalp and APO Softworks Authors. All rights reserved.\r\n* Use of this source code is governed by a BSD-style license that can be\r\n* found in the LICENSE file.\r\n*/\r\n\r\nimport Validator from \"./modules/validator\"\r\nexport default Validator\r\n\r\n// rules export\r\nexport { default as rules } \t\tfrom \"./rules/index\"\r\nexport { setRule as setRule } \t\tfrom \"./rules/index\"\r\nexport { setRules as setRules } \tfrom \"./rules/index\"\r\nexport { clearRules as clearRules } from \"./rules/index\""],"names":["CustomException","DateTime"],"mappings":"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"}