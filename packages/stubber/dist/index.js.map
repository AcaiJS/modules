{"version":3,"file":"index.js","sources":["../src/utils/parseArgs.ts","../src/utils/getStubs.ts","../src/modules/Stubber.ts","../src/utils/listStubs.ts","../src/index.ts"],"sourcesContent":["export default function parseArgs (args: string[]) {\n\tconst variables \t= {} as Record<string, string>\n\tconst [stub, name] \t= args\n\n\targs.splice(1).forEach(item => {\n\t\tconst [name, value] = item.split(\"=\")\n\t\tvariables[name] \t= value || \"\"\n\t})\n\n\treturn {\n\t\tstubName: stub,\n\t\tstubArgs: {...variables, name},\n\t}\n}","// Packages\nimport * as fs \t\tfrom \"fs\"\nimport * as path \tfrom \"path\"\n\nexport default function getStubs(stubFilesPath: string) {\n\tconst stubpath = path.join(process.cwd(), stubFilesPath)\n\n\t// find stubs directory\n\tif (!fs.existsSync(stubpath)) {\n\t\tthrow new Error(\"Stubs directory does not exist\")\n\t}\n\n\t// check if is an actual directory\n\tif (!fs.lstatSync(stubpath).isDirectory()) {\n\t\tthrow new Error(\"Stubs directory is not a directory\")\n\t}\n\n\t// read its content\n\tconst stubsAvailable = fs.readdirSync(stubpath, {withFileTypes: true}).filter( i => i.isDirectory())\n\n\n\tfor (let i = 0; i < stubsAvailable.length; i++) {\n\t\tconst item \t\t\t\t= stubsAvailable[i]\n\t\tconst configFilePath \t= path.join(stubpath, item.name, \"stub.config.json\")\n\n\t\t// check config file\n\t\tif (!fs.existsSync(configFilePath)) {\n\t\t\tthrow new Error(`Stub ${item.name} does not have a config file`)\n\t\t}\n\n\t\t// load config file\n\t\ttry {\n\t\t\tJSON.parse(fs.readFileSync(configFilePath, {encoding: \"utf-8\"}))\n\t\t}\n\t\tcatch (e) {\n\t\t\tthrow new Error(`Stub ${item.name} config is not a valid JSON`)\n\t\t}\n\t}\n\n\treturn stubsAvailable\n}","// Packages\nimport * as fs \t\tfrom \"fs\"\nimport * as path \tfrom \"path\"\nimport { glob } \tfrom \"glob\"\n\n// Interfaces\nimport StubConfigInterface from \"../interfaces/stubConfig\"\n\n// Utils\nimport parseArgs from \"../utils/parseArgs\"\nimport getStubs from \"../utils/getStubs\"\n\nexport default class Stubber {\n\t// -------------------------------------------------\n\t// Properties\n\t// -------------------------------------------------\n\n\tprotected callArgs\t\t\t: ReturnType<typeof parseArgs>;\n\tprotected stubConfig\t\t: StubConfigInterface;\n\tprotected stubFileContent\t: string[];\n\tprotected stubOriginPath\t: string;\n\n\t// -------------------------------------------------\n\t// Constructor\n\t// -------------------------------------------------\n\n\tpublic constructor (args: string[], stubFilesPath = \"\", overwriteTargetPath?: string) {\n\t\tconst stubpath = path.join(process.cwd(), stubFilesPath)\n\n\t\t// find stubs directory\n\t\tif (!fs.existsSync(stubpath)) {\n\t\t\tthrow \"Stubs directory does not exist\"\n\t\t}\n\n\t\t// check if is an actual directory\n\t\tif (!fs.lstatSync(stubpath).isDirectory()) {\n\t\t\tthrow \"Stubs directory is not a directory\"\n\t\t}\n\n\t\t// read its content\n\t\tconst stubsAvailable = fs.readdirSync(stubpath, {withFileTypes: true}).filter( i => i.isDirectory())\n\n\t\t// parse arguments\n\t\tthis.callArgs \t= parseArgs(args)\n\t\tconst stubs \t= getStubs(stubFilesPath)\n\n\t\tfor (let i = 0; i < stubs.length; i++) {\n\t\t\tconst item \t\t\t\t= stubsAvailable[i]\n\t\t\tconst configFilePath \t= path.join(stubpath, item.name, \"stub.config.json\")\n\n\t\t\t// load config file\n\t\t\tconst config = JSON.parse(fs.readFileSync(configFilePath, {encoding: \"utf-8\"})) as StubConfigInterface\n\n\t\t\tif (config.name === this.callArgs.stubName) {\n\t\t\t\tthis.stubConfig \t= config\n\t\t\t\tthis.stubOriginPath = path.join(stubpath, item.name).replace(/(\\\\|\\/|\\\\\\\\|\\/\\/)/g, \"/\")\n\n\t\t\t\t// load all files inside of the stub directory\n\t\t\t\tthis.stubFileContent = glob.sync(path.join(this.stubOriginPath, \"**/*\"), {nodir: true})\n\n\t\t\t\t// stub found, break find\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// stub not found\n\t\tif (!this.stubConfig) {\n\t\t\tthrow `Search for the stub ${this.callArgs.stubName} did not return any results`\n\t\t}\n\n\t\t// update target path\n\t\tif (overwriteTargetPath) this.stubConfig.targetPath = overwriteTargetPath\n\t}\n\n\t// -------------------------------------------------\n\t// Copy stub\n\t// -------------------------------------------------\n\n\tpublic copy() {\n\t\tconst targetPath = this.stubConfig.targetPath\n\n\t\tif (!targetPath) {\n\t\t\tthrow `Stub ${this.stubConfig.name} does not have a target path, stubber doesn't know where to put it`\n\t\t}\n\n\t\t// copy all files\n\t\tthis.stubFileContent.forEach(item => {\n\t\t\tconst shouldBeRenamed\t= !!(this.stubConfig.renameToNameFiles && this.stubConfig.renameToNameFiles.find(i => i === item.replace(/(\\\\|\\/)/g, \"/\").replace(this.stubOriginPath, \"\").split(\"/\").splice(1).join(\"/\")))\n\t\t\tconst relativepath \t\t= item.replace(/(\\\\|\\/)/g, \"/\").replace(this.stubOriginPath, \"\").replace(shouldBeRenamed ? /\\/\\w+\\./:\"\", shouldBeRenamed ? `/${this.callArgs.stubArgs.name}.`:\"\")\n\t\t\tconst targetfinalpath\t= path.join(process.cwd(), targetPath, relativepath).replace(/(\\\\|\\/)/g, \"/\")\n\n\t\t\t// skip config, we don't want to copy that\n\t\t\tif (relativepath === \"/stub.config.json\") return\n\n\t\t\t// make sure the directory exists\n\t\t\t{\n\t\t\t\tconst pathfile = targetfinalpath.substring(0, targetfinalpath.lastIndexOf(\"/\"))\n\t\t\t\tif (!fs.existsSync(pathfile)){\n\t\t\t\t\tfs.mkdirSync(pathfile, {recursive: true})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// copy it\n\t\t\tfs.copyFileSync(item, targetfinalpath)\n\t\t})\n\t}\n\n\t// -------------------------------------------------\n\t// Variable injection\n\t// -------------------------------------------------\n\n\tpublic inject (extraVariables?: Record<string, string>) {\n\t\tconst allVariables = { ...this.stubConfig.variables, ...this.callArgs.stubArgs, ...(extraVariables || {})}\n\n\t\t// loop all files\n\t\tthis.stubFileContent.forEach(item => {\n\t\t\tconst shouldBeRenamed\t= !!(this.stubConfig.renameToNameFiles && this.stubConfig.renameToNameFiles.find(i => i === item.replace(/(\\\\|\\/)/g, \"/\").replace(this.stubOriginPath, \"\").split(\"/\").splice(1).join(\"/\")))\n\t\t\tconst relativepath \t\t= item.replace(/(\\\\|\\/)/g, \"/\").replace(this.stubOriginPath, \"\").replace(shouldBeRenamed ? /\\/\\w+\\./:\"\", shouldBeRenamed ? `/${this.callArgs.stubArgs.name}.`:\"\")\n\t\t\tconst targetfinalpath\t= path.join(process.cwd(), this.stubConfig.targetPath, relativepath).replace(/(\\\\|\\/)/g, \"/\")\n\n\t\t\t// skip config, we don't want to copy that\n\t\t\tif (relativepath === \"/stub.config.json\") return\n\n\t\t\t// get file content\n\t\t\tlet content = fs.readFileSync(targetfinalpath, { encoding: \"utf-8\" })\n\n\t\t\t// parse all variables\n\t\t\tconst variables = (content.match(/{{\\s*\\S+\\s*}}/g) || [])\n\n\t\t\t// exchange all variables\n\t\t\tvariables.forEach(variable => {\n\t\t\t\tconst varname \t= variable.replace(/({{|}})/g, \"\").trim()\n\t\t\t\tconst varvalue\t= allVariables[varname]\n\n\t\t\t\tif (!varvalue) {\n\t\t\t\t\tconsole.log(`\\x1b[33mwarning\\x1b[0m - variable ${varname} not found, passing an empty string`)\n\t\t\t\t}\n\n\t\t\t\tcontent = content.replace(new RegExp(`${variable}`), varvalue || \"\")\n\t\t\t})\n\n\t\t\t// save back the updated content\n\t\t\tfs.writeFileSync(targetfinalpath, content, { encoding: \"utf-8\" })\n\t\t})\n\t}\n}","// Packages\nimport * as fs \t\tfrom \"fs\"\nimport * as path \tfrom \"path\"\n\n// Interfaces\nimport StubConfigInterface from \"../interfaces/stubConfig\"\n\n// Utils\nimport getStubs from \"./getStubs\"\n\nexport default function listStubs (stubpath: string) {\n\tconst stubs \t= getStubs(stubpath)\n\n\tstubs.forEach((item) => {\n\t\tconst configFilePath \t= path.join(process.cwd(), stubpath, item.name, \"stub.config.json\")\n\n\t\t// load config file\n\t\tconst config = JSON.parse(fs.readFileSync(configFilePath, {encoding: \"utf-8\"})) as StubConfigInterface\n\t\tconsole.log(`\\nstub: ${config.name}`)\n\t\tif (config.description) console.log(\"description:\", config.description.length > 70 ? `${config.description.substring(0, 70)}...`:config.description)\n\t})\n}","/**\r\n* Copyright (c) 2020 The Nuinalp and APO Softworks Authors. All rights reserved.\r\n* Use of this source code is governed by a BSD-style license that can be\r\n* found in the LICENSE file.\r\n*/\r\n\r\nimport Stubber \t\tfrom \"./modules/Stubber\"\r\nimport listStubs \tfrom \"./utils/listStubs\"\r\n\r\nconst [action, ...args] = process.argv.splice(2)\r\n\r\nif (!action) {\r\n\tconsole.log(\"\")\r\n\tconsole.log(\"\\x1b[47m\\x1b[30m Welcome to the stubber \\x1b[0m\\n\")\r\n\tconsole.log(\"Stubber is part of the \\x1b[4m\\x1b[35mAçaí framework\\x1b[37m and is used to easily create commonly used files, such as controllers, middlewares or components. You can checkout the help or commands action to see how to use it. You can chekout a more detailed documentation at: https://github.com/AcaiFramework/stubber\")\r\n\tconsole.log(\"\")\r\n}\r\nelse if (action === \"commands\") {\r\n\tconsole.log(\"\\n\\x1b[47m\\x1b[30m Stubber commands \\x1b[0m\\n\\n\")\r\n\tconsole.log(\"\\x1b[47m\\x1b[30m help \\x1b[0m - A short description of how to instantiate and use the stubber. Accepts an second argument of the stub name, and return it's description\\n\")\r\n\tconsole.log(\"\\x1b[47m\\x1b[30m commands \\x1b[0m - displays this text of list of commands\\n\")\r\n\tconsole.log(\"\\x1b[47m\\x1b[30m spawn \\x1b[0m - receives a required argument of the name of the stub to use\\n\")\r\n\tconsole.log(\"\\x1b[47m\\x1b[30m list \\x1b[0m - list all available stubs to spawn\\n\")\r\n}\r\nelse if (action === \"help\") {\r\n\tconsole.log(\"\\n\\x1b[47m\\x1b[30m Stubber help \\x1b[0m\\n\\n\")\r\n\r\n\tconsole.log(\"Creating your stubs\\n\")\r\n\tconsole.log(\"By any way this is a complete guide, just a quickstart, you can read more in https://github.com/AcaiFramework/stubber\")\r\n\tconsole.log(\"To create your stubs, the first thing you will need is a directory to them. Stubber defaults to `/stubs`, but you can overwrite it using `--stubDir=/path/to/dir`, each folder inside of it will be considered a different stub, and all of them require a file called `stub.config.json`, where it's name and identifier can be found.\")\r\n\tconsole.log(\"You need two keys: name and targetPath, that's where the stub will be place when called. Behaviour that you can overwrite using `--target=/new/path`, every other file inside of the stub, will be copied to the target path, meaning you can write variables inside of them.\")\r\n\tconsole.log(\"To declare those variables, you will enclose them within double brackets, like this: `{{ variableName }}`, there are many types of variables and you can read about them in our documentation. The variable name defaults to the name you give your stub.\")\r\n\r\n\tconsole.log(\"\\nUsing them\\n\")\r\n\tconsole.log(\"You can call this package within your terminal, we recommend saving it in your package.json, so you can alias it to a smaller form. Let's say for example you have a stub called Component and wants to use it, just call: `yarn stub spawn Component MyComponent` and there you have it.\")\r\n\tconsole.log(\"\")\r\n}\r\nelse if (action === \"list\") {\r\n\tconsole.log(\"\\n\\x1b[47m\\x1b[30m List of available stubs \\x1b[0m\")\r\n\tconsole.log(\"You can read more with command help {stubName}\")\r\n\r\n\tlistStubs((args.find(i => i.match(\"--stubDir=\")) || \"--stubDir=/stubs\").replace(\"--stubDir=\", \"\"))\r\n\r\n\tconsole.log(\"\")\r\n}\r\nelse if (action === \"spawn\") {\r\n\tif (args.length < 2) {\r\n\t\tthrow \"Not enough arguments to spawn the required stub\"\r\n\t}\r\n\r\n\tconsole.log(`\\nSpawning stub ${args[0]}`)\r\n\r\n\tconst stubber = new Stubber(args, (args.find(i => i.match(\"--stubDir=\")) || \"--stubDir=/stubs\").replace(\"--stubDir=\", \"\"))\r\n\tstubber.copy()\r\n\tstubber.inject()\r\n\r\n\tconsole.log(\"\")\r\n}\r\nelse {\r\n\tthrow \"Command not found, see list of commands to see all available options\"\r\n}"],"names":["join","existsSync","lstatSync","readdirSync","readFileSync","join2","existsSync2","lstatSync2","readdirSync2","readFileSync2","glob","mkdirSync","copyFileSync","writeFileSync","join3","readFileSync3"],"mappings":"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"}