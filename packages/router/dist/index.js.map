{"version":3,"file":"index.js","sources":["../src/utils/context.ts","../src/modules/route.ts","../src/utils/buildQueryParams.ts","../src/modules/router.ts"],"sourcesContent":["// Interfaces\r\nimport Options \t\t\t\t\tfrom \"../interfaces/routeOptions\"\r\nimport Route \t\t\t\t\tfrom \"../interfaces/route\"\r\nimport methodTypes\t\t\t\tfrom \"../interfaces/method\"\r\nimport RouteOptionsInterface\tfrom \"../interfaces/routeOptions\"\r\n\r\n// -------------------------------------------------\r\n// Properties\r\n// -------------------------------------------------\r\n\r\nlet context\t\t: Options \t\t\t\t\t\t\t\t\t= {options:{}}\r\nlet routes\t\t: Route[] \t\t\t\t\t\t\t\t\t= []\r\nlet cbs\t\t\t: (() => void)[] \t\t\t\t\t\t\t= []\r\nlet macros\t\t: Record<string, (...args: any[]) => void> \t= {}\r\n\r\n// -------------------------------------------------\r\n// Context\r\n// -------------------------------------------------\r\n\r\nexport const getContext = (): Options => context\r\n\r\nexport const setContext = ({options, ...newContext}: Partial<Options>, lastoptions: Options[\"options\"]): void => {\r\n\tconst newoptions = {...lastoptions}\r\n\r\n\tif (options) {\r\n\t\tObject.keys(options).forEach(key => {\r\n\t\t\tif (!key.match(/^!/)) {\r\n\t\t\t\tif (Array.isArray(options[key]) && Array.isArray(lastoptions[key])) {\r\n\t\t\t\t\tconst arr = options[key] as string[]\r\n\t\t\t\t\tnewoptions[key] = [...(lastoptions[key] as string[]).filter(i => !arr.find(x => x === i)), ...arr]\r\n\t\t\t\t}\r\n\t\t\t\telse if (typeof options[key] === \"object\" && typeof lastoptions[key] === \"object\") {\r\n\t\t\t\t\tnewoptions[key] = {...(lastoptions[key] as Record<string, string>), ...(options[key] as Record<string, string>)}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewoptions[key] = options[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnewoptions[key.replace(/^!/, \"\")] = options[key]\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tcontext = { ...newContext, options: {...newoptions} }\r\n}\r\n\r\nexport const clearContext = (): void => {\r\n\tcontext = {options:{}}\r\n}\r\n\r\n// -------------------------------------------------\r\n// Routes\r\n// -------------------------------------------------\r\n\r\nexport const getRoutes = (): typeof routes => routes\r\n\r\nexport const addRoute = (view: string, path: string, method: methodTypes, options: Partial<Options>) => {\r\n\t// gather data\r\n\tconst { prefix, ..._context } = getContext()\r\n\tconst completepath = `/${(prefix === undefined ? \"/\" : prefix) + path}`.replace(/\\/$/, \"\").replace(\r\n\t\t/^(\\\\+|\\/+)/gm,\r\n\t\t\"/\",\r\n\t)\r\n\tconst clearview = typeof view === \"string\" ? view\r\n\t\t.replace(/(\\\\+|\\/+)/gm, \"/\")\r\n\t\t.replace(/(\\\\|\\/)$/gm, \"\")\r\n\t\t.replace(/^(\\\\|\\/)/gm, \"\"):view\r\n\r\n\t// push to routes\r\n\troutes.push({\r\n\t\tfile: clearview,\r\n\t\tpath: completepath,\r\n\t\tmethod,\r\n\t\toptions: {\r\n\t\t\t..._context.options,\r\n\t\t\t...options,\r\n\t\t},\r\n\t})\r\n\r\n\tconst index = routes.length - 1\r\n\r\n\treturn {\r\n\t\toptions: (newoptions: RouteOptionsInterface[\"options\"]) => {\r\n\t\t\troutes[index].options = {\r\n\t\t\t\t...routes[index].options,\r\n\t\t\t\t...newoptions,\r\n\t\t\t}\r\n\t\t},\r\n\t}\r\n}\r\n\r\nexport const clearRoutes = (): void => {\r\n\troutes = []\r\n}\r\n\r\n// -------------------------------------------------\r\n// Context\r\n// -------------------------------------------------\r\n\r\nexport const getCallbacks = (): typeof cbs => cbs\r\n\r\nexport const addCallback = (newCallback: () => void): void => {\r\n\tcbs.push(newCallback)\r\n}\r\n\r\nexport const clearCallbacks = (): void => {\r\n\tcbs = []\r\n}\r\n\r\n// -------------------------------------------------\r\n// Macros\r\n// -------------------------------------------------\r\n\r\nexport const getMacro = (name: string) => {\r\n\tif (!macros[name]) {\r\n\t\tthrow new Error(`Macro '${name}' not found`)\r\n\t}\r\n\r\n\treturn macros[name]\r\n}\r\n\r\nexport const setMacro = (name: string, callback: (...args: any[]) => void) => {\r\n\tmacros[name] = callback\r\n}\r\n\r\nexport const clearMacros = () => macros = {}\r\n","// Interfaces\r\nimport methodTypes \t\t\t\tfrom \"../interfaces/method\"\r\nimport RouteInterface\t\t\tfrom \"../interfaces/route\"\r\nimport RouteModuleInterface\t\tfrom \"../interfaces/routeMethod\"\r\nimport RouteOptionsInterface \tfrom \"../interfaces/routeOptions\"\r\n\r\n// Utils\r\nimport { addRoute, clearRoutes, getMacro, getRoutes }\tfrom \"../utils/context\"\r\nimport { addCallback, clearCallbacks, getCallbacks }\tfrom \"../utils/context\"\r\nimport { clearContext, getContext, setContext }\t\t\tfrom \"../utils/context\"\r\nimport { setMacro }\t\t\t\t\t\t\t\t\t\tfrom \"../utils/context\"\r\n\r\n// -------------------------------------------------\r\n// HTTP Methods\r\n// -------------------------------------------------\r\n\r\nconst routeAnyMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"ANY\", options)\r\n}\r\n\r\nconst routeGetMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"GET\", options)\r\n}\r\n\r\nconst routePostMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"POST\", options)\r\n}\r\n\r\nconst routePatchMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"PATCH\", options)\r\n}\r\n\r\nconst routePutMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"PUT\", options)\r\n}\r\n\r\nconst routeDeleteMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"DELETE\", options)\r\n}\r\n\r\n// -------------------------------------------------\r\n// Helpers\r\n// -------------------------------------------------\r\n\r\nconst routeMacro = (name: string, callback: (...args: any[]) => void) => {\r\n\tsetMacro(name, callback)\r\n}\r\n\r\nconst routeUseMacro = async (name: string, ...args: any[]) => {\r\n\tconst callback = getMacro(name)\r\n\tawait callback(...args)\r\n}\r\n\r\nconst routeOptions = (options: RouteOptionsInterface[\"options\"], callback: () => void) => {\r\n\tconst c \t\t\t= { ...getContext(), options: {... options} }\r\n\tconst lastoptions\t= {...getContext().options}\r\n\r\n\taddCallback(() => {\r\n\t\tsetContext(c, lastoptions)\r\n\r\n\t\tcallback()\r\n\t})\r\n}\r\n\r\nconst routeMany = (method: methodTypes[], path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\tif (method.includes(\"GET\"))\r\n\t\trouteGetMethod(path, filePath, options)\r\n\tif (method.includes(\"PUT\"))\r\n\t\troutePutMethod(path, filePath, options)\r\n\tif (method.includes(\"POST\"))\r\n\t\troutePostMethod(path, filePath, options)\r\n\tif (method.includes(\"PATCH\"))\r\n\t\troutePatchMethod(path, filePath, options)\r\n\tif (method.includes(\"DELETE\"))\r\n\t\trouteDeleteMethod(path, filePath, options)\r\n}\r\n\r\nconst routeGroup = (prefix: string, callback: () => void, options?: RouteOptionsInterface) => {\r\n\tconst cprefix \t\t= (getContext().prefix === undefined ? \"\" : getContext().prefix) + (prefix || \"\")\r\n\tconst c \t\t\t= { ...getContext(), ...options, prefix: cprefix }\r\n\tconst lastoptions\t= {...getContext().options}\r\n\r\n\taddCallback(() => {\r\n\t\tsetContext(c, lastoptions)\r\n\r\n\t\tcallback()\r\n\t})\r\n}\r\n\r\nconst routeBuild = <T = Record<string, unknown>>(clearCache = true) => {\r\n\tlet cbs = getCallbacks()\r\n\r\n\twhile (cbs.length > 0) {\r\n\t\tclearCallbacks()\r\n\r\n\t\t// run all groups\r\n\t\tfor (let i = 0; i < cbs.length; i += 1) {\r\n\t\t\tcbs[i]()\r\n\t\t}\r\n\r\n\t\t// break loop if no callbacks left\r\n\t\tcbs = getCallbacks()\r\n\t}\r\n\r\n\t// build components\r\n\tconst routes = getRoutes()\r\n\r\n\t// clear registered routes\r\n\tif (clearCache) clearRoutes()\r\n\r\n\t// filter repeated routes\r\n\tconst filteredroutes = [] as typeof routes\r\n\troutes.reverse().forEach(i => {if (!filteredroutes.find(x => x.path === i.path && x.method === i.method)) filteredroutes.push(i) })\r\n\treturn filteredroutes.reverse() as RouteInterface<T>[]\r\n}\r\n\r\nconst clearMethod = () => {\r\n\tclearRoutes()\r\n\tclearContext()\r\n}\r\n\r\n// -------------------------------------------------\r\n// Add default macro\r\n// -------------------------------------------------\r\n\r\nrouteMacro(\"resource\", (name: string, file: string) => {\r\n\trouteGetMethod(`${name}`, \t`${file}@index`)\r\n\troutePostMethod(`${name}`, \t`${file}@store`)\r\n\r\n\trouteGroup(\"/{id}\", () => {\r\n\t\trouteGetMethod(\"/\", \t`${file}@show`)\r\n\t\troutePatchMethod(\"/\", \t`${file}@update`)\r\n\t\troutePutMethod(\"/\", \t`${file}@update`)\r\n\t\trouteDeleteMethod(\"/\", \t`${file}@destroy`)\r\n\t})\r\n})\r\n\r\n// -------------------------------------------------\r\n// Exports\r\n// -------------------------------------------------\r\n\r\nconst route \t= routeAnyMethod as RouteModuleInterface\r\nroute.any\t\t= routeAnyMethod\r\nroute.get\t\t= routeGetMethod\r\nroute.post\t\t= routePostMethod\r\nroute.put\t\t= routePutMethod\r\nroute.patch\t\t= routePatchMethod\r\nroute.delete\t= routeDeleteMethod\r\nroute.options \t= routeOptions\r\nroute.group\t\t= routeGroup\r\nroute.many\t\t= routeMany\r\nroute.build\t\t= routeBuild\r\nroute.clear\t\t= clearMethod\r\nroute.macro\t\t= routeMacro\r\nroute.use\t\t= routeUseMacro\r\n\r\nexport default route as RouteModuleInterface","function stringToType (str: string) {\n\tif (str === \"true\") return true\n\tif (str === \"false\") return false\n\tif (`${parseFloat(str)}` === str) return parseFloat(str)\n\n\treturn str\n}\n\nexport default function buildQueryParams (prepath = \"\") {\n\tconst [path, ...preargs] = prepath.split(\"?\")\n\tconst args = {} as Record<string, number | string | boolean>\n\n\t(new URLSearchParams(preargs.join(\"?\"))).forEach((val, key) => args[key] = stringToType(val) || true)\n\n\treturn [path, args] as const\n}","// Interfaces\r\nimport RouteInterface from \"../interfaces/route\"\r\nimport MethodTypes from \"../interfaces/method\"\r\nimport RouterConfigInterface from \"../interfaces/routerConfig\"\r\n\r\n// Utils\r\nimport buildQueryParams from \"../utils/buildQueryParams\"\r\n\r\n/**\r\n * # Router\r\n *\r\n * Get a list of routes and find the correspondent based on the given routes.\r\n *\r\n * @param {string} path current url path to be analyzed against all routes\r\n * @param {string} method HTTP method to match to\r\n * @param {RouteInterface[]} routes list of available routes that can be matched\r\n * @param {RouterConfigInterface?} config extra config options to customize the router behaviour\r\n */\r\nconst routerModule = <Options = Record<string, string>> (path: string, method: MethodTypes, routes: RouteInterface[], config: RouterConfigInterface = {}) => {\r\n\t// prepare data\r\n\tconst sanitizedpath = path.replace(/(\\\\|\\/)^/, \"\")\r\n\tconst [clearpath, queryParams] = buildQueryParams(sanitizedpath)\r\n\tconst variablematch = new RegExp(`${config.variableEnclose || \"{\"}\\\\s*\\\\S+\\\\??\\\\s*${config.variableEnclose || \"}\"}`)\r\n\tconst optionalVariableMatch = new RegExp(`\\\\?{1}\\\\s*${config.variableEnclose || \"}\"}`)\r\n\tlet variables = {} as Record<string, string | string[]>\r\n\r\n\t// Match routes\r\n\tconst route = routes.find((route) => {\r\n\t\tvariables = {}\r\n\t\tconst splitpath = route.path.split(\"/\").filter(i => i !== \"\")\r\n\t\tconst possibleMatch = clearpath.split(\"/\").filter(i => i !== \"\")\r\n\r\n\t\t// check route http method\r\n\t\tif (method !== route.method && !(method === \"OPTIONS\" && config.allowOptionsMatch !== false) && route.method !== \"ANY\") return false\r\n\r\n\t\t// check by length\r\n\t\tif (possibleMatch.length > splitpath.length && splitpath[splitpath.length - 1] !== \"*\") {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\t// filter by the actual route\r\n\t\tconst matches = splitpath.filter((part, index) => {\r\n\t\t\tconst isVar \t\t= variablematch.test(part)\r\n\t\t\tconst isOptionalVar = optionalVariableMatch.test(part)\r\n\t\t\tconst varName \t\t= part.replace(new RegExp(`${config.variableEnclose || \"{\"}\\\\s*`), \"\").replace(new RegExp(`\\\\??\\\\s*${config.variableEnclose || \"}\"}`), \"\")\r\n\r\n\t\t\tif (isVar) {\r\n\t\t\t\tif (possibleMatch[index]) {\r\n\t\t\t\t\tvariables[varName] = possibleMatch[index]\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isOptionalVar) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn !possibleMatch[index]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn part !== possibleMatch[index]\r\n\t\t\t}\r\n\t\t}).length\r\n\r\n\t\t// add extra if necessary\r\n\t\tif (!matches && splitpath[splitpath.length - 1] === \"*\" && possibleMatch.length > splitpath.length) {\r\n\t\t\tvariables[\"*\"] = possibleMatch.splice(0, splitpath.length)\r\n\t\t}\r\n\r\n\t\treturn !matches\r\n\t})\r\n\r\n\tif (route)\r\n\t\treturn {...route, options: route.options as Options, variables, query: queryParams}\r\n\r\n\treturn undefined\r\n}\r\n\r\nexport default routerModule"],"names":["context","options","routes","cbs","macros","getContext","setContext","newContext","lastoptions","newoptions","keys","forEach","key","match","replace","Array","isArray","arr","filter","find","x","i","clearContext","getRoutes","addRoute","view","path","method","prefix","_context","completepath","clearview","push","file","index","length","clearRoutes","getCallbacks","addCallback","newCallback","clearCallbacks","getMacro","name","Error","setMacro","callback","routeAnyMethod","filePath","routeGetMethod","routePostMethod","routePatchMethod","routePutMethod","routeDeleteMethod","routeMacro","routeUseMacro","async","args","routeOptions","c","routeMany","includes","routeGroup","cprefix","routeBuild","clearCache","cbs2","routes2","filteredroutes","reverse","clearMethod","route","any","get","post","put","patch","delete","group","many","build","clear","macro","use","route_default","str","parseFloat","prepath","preargs","split","URLSearchParams","join","val","stringToType","routerModule","config","clearpath","queryParams","buildQueryParams","variablematch","RegExp","variableEnclose","optionalVariableMatch","variables","route2","splitpath","route3","possibleMatch","allowOptionsMatch","matches","part","isVar","test","isOptionalVar","varName","splice","query","router_default"],"mappings":";;;;wEAUA,IAAIA,QAA8B,CAACC,QAAQ,IACvCC,OAA6B,GAC7BC,IAAgC,GAChCC,OAAsD,GAM7CC,WAAa,IAAeL,QAE5BM,WAAa,CAAC,CAACL,QAAAA,KAAYM,GAA+BC,WAChEC,EAAa,IAAID,GAEnBP,UACIS,KAAKT,GAASU,QAAQ,OACvBC,EAAIC,MAAM,QAaHD,EAAIE,QAAQ,KAAM,KAAOb,EAAQW,WAZxCG,MAAMC,QAAQf,EAAQW,KAASG,MAAMC,QAAQR,EAAYI,IAAO,OAC7DK,EAAMhB,EAAQW,KACTA,GAAO,IAAKJ,EAAYI,GAAkBM,OAAO,IAAMD,EAAIE,KAAK,GAAKC,IAAMC,OAAQJ,OAE9D,iBAAjBhB,EAAQW,IAAiD,iBAArBJ,EAAYI,KACpDA,GAAO,IAAKJ,EAAYI,MAAqCX,EAAQW,MAGrEA,GAAOX,EAAQW,aASpB,IAAKL,EAAYN,QAAS,IAAIQ,KAG5Ba,aAAe,aACjB,CAACrB,QAAQ,KAOPsB,UAAY,IAAqBrB,OAEjCsB,SAAW,CAACC,EAAcC,EAAcC,EAAqB1B,UAEnE,CAAE2B,OAAAA,KAAWC,GAAaxB,aAC1ByB,YAA+B,MAAY,IAAMF,GAAUF,IAAOZ,QAAQ,MAAO,IAAIA,QAC1F,eACA,KAEKiB,EAA4B,iBAATN,EAAoBA,EAC3CX,QAAQ,cAAe,KACvBA,QAAQ,aAAc,IACtBA,QAAQ,aAAc,IAAIW,SAGrBO,KAAK,CACXC,KAAMF,EACNL,KAAMI,EACNH,OAAAA,EACA1B,QAAS,IACL4B,EAAS5B,WACTA,WAICiC,EAAQhC,OAAOiC,OAAS,QAEvB,CACNlC,QAAS,WACDiC,GAAOjC,QAAU,IACpBC,OAAOgC,GAAOjC,WACdQ,MAMM2B,YAAc,YACjB,IAOGC,aAAe,IAAkBlC,IAEjCmC,YAAc,QACtBN,KAAKO,IAGGC,eAAiB,SACvB,IAOMC,SAAW,QAClBrC,OAAOsC,SACL,IAAIC,gBAAgBD,uBAGpBtC,OAAOsC,IAGFE,SAAW,CAACF,EAAcG,YAC/BH,GAAQG,GC3GVC,eAAiB,CAACpB,EAAcqB,EAAkB9C,EAA0C,KAC1FuB,SAASuB,EAAUrB,EAAM,MAAOzB,GAGlC+C,eAAiB,CAACtB,EAAcqB,EAAkB9C,EAA0C,KAC1FuB,SAASuB,EAAUrB,EAAM,MAAOzB,GAGlCgD,gBAAkB,CAACvB,EAAcqB,EAAkB9C,EAA0C,KAC3FuB,SAASuB,EAAUrB,EAAM,OAAQzB,GAGnCiD,iBAAmB,CAACxB,EAAcqB,EAAkB9C,EAA0C,KAC5FuB,SAASuB,EAAUrB,EAAM,QAASzB,GAGpCkD,eAAiB,CAACzB,EAAcqB,EAAkB9C,EAA0C,KAC1FuB,SAASuB,EAAUrB,EAAM,MAAOzB,GAGlCmD,kBAAoB,CAAC1B,EAAcqB,EAAkB9C,EAA0C,KAC7FuB,SAASuB,EAAUrB,EAAM,SAAUzB,GAOrCoD,WAAa,CAACX,EAAcG,cACxBH,EAAMG,IAGVS,cAAgBC,MAAOb,KAAiBc,WACvCX,EAAWJ,SAASC,SACpBG,KAAYW,IAGbC,aAAe,CAACxD,EAA2C4C,WAC1Da,EAAO,IAAKrD,aAAcJ,QAAS,IAAKA,IACxCO,EAAc,IAAIH,aAAaJ,qBAEzB,gBACAyD,EAAGlD,UAMVmD,UAAY,CAAChC,EAAuBD,EAAcqB,EAAkB9C,EAA0C,MAC/G0B,EAAOiC,SAAS,uBACJlC,EAAMqB,EAAU9C,GAC5B0B,EAAOiC,SAAS,uBACJlC,EAAMqB,EAAU9C,GAC5B0B,EAAOiC,SAAS,yBACHlC,EAAMqB,EAAU9C,GAC7B0B,EAAOiC,SAAS,2BACFlC,EAAMqB,EAAU9C,GAC9B0B,EAAOiC,SAAS,6BACDlC,EAAMqB,EAAU9C,IAG9B4D,WAAa,CAACjC,EAAgBiB,EAAsB5C,KACnD6D,QAAqC,iBAAXlC,OAAuB,GAAKvB,aAAauB,YAAqB,UACxF8B,EAAO,IAAKrD,gBAAiBJ,EAAS2B,OAAQkC,GAC9CtD,EAAc,IAAIH,aAAaJ,qBAEzB,gBACAyD,EAAGlD,UAMVuD,WAAa,CAA8BC,GAAa,SACzDC,EAAM5B,oBAEU,EAAb4B,EAAI9B,QAAY,0BAIbd,EAAI,EAAGA,EAAI4C,EAAI9B,OAAQd,GAAK,IAChCA,OAICgB,qBAID6B,EAAS3C,YAGXyC,uBAGEG,EAAiB,YAChBC,UAAUzD,QAAQ,IAAWwD,EAAehD,KAAK,GAAKC,EAAEM,OAASL,EAAEK,MAAQN,EAAEO,SAAWN,EAAEM,WAAwBK,KAAKX,KACvH8C,EAAeC,WAGjBC,YAAc,mCASpBhB,WAAW,WAAY,CAACX,EAAcT,uBACnBS,OAAYT,8BACXS,OAAYT,sBAEpB,QAAS,oBACJ,OAASA,2BACP,OAASA,2BACX,OAASA,8BACN,OAASA,iBAQ7B,IAAMqC,MAASxB,eACfwB,MAAMC,IAAOzB,eACbwB,MAAME,IAAOxB,eACbsB,MAAMG,KAAQxB,gBACdqB,MAAMI,IAAOvB,eACbmB,MAAMK,MAASzB,iBACfoB,MAAMM,OAASxB,kBACfkB,MAAMrE,QAAWwD,aACjBa,MAAMO,MAAShB,WACfS,MAAMQ,KAAQnB,UACdW,MAAMS,MAAShB,WACfO,MAAMU,MAASX,YACfC,MAAMW,MAAS5B,WACfiB,MAAMY,IAAO5B,kBAEN6B,cAAQb,MC5Jf,sBAAuBc,SACV,SAARA,GACQ,UAARA,OACGC,WAAWD,OAAWA,EAAYC,WAAWD,GAE7CA,GAGO,0BAA2BE,EAAU,SAC7C,CAAC5D,KAAS6D,GAAWD,EAAQE,MAAM,KACnChC,EAAO,UAEZ,IAAIiC,gBAAgBF,EAAQG,KAAK,MAAO/E,QAAQ,CAACgF,EAAK/E,IAAQ4C,EAAK5C,GAAOgF,aAAaD,KAAQ,GAEzF,CAACjE,EAAM8B,GCIf,IAAMqC,aAAe,CAAoCnE,EAAcC,EAAqBuC,EAA0B4B,EAAgC,WAG/I,CAACC,EAAWC,GAAeC,iBADXvE,EAAKZ,QAAQ,WAAY,KAEzCoF,EAAgB,IAAIC,UAAUL,EAAOM,iBAAmB,sBAAsBN,EAAOM,iBAAmB,OACxGC,EAAwB,IAAIF,oBAAoBL,EAAOM,iBAAmB,WAC5EE,EAAY,GAGVC,EAAQrC,EAAO/C,KAAK,MACb,SACNqF,EAAYC,EAAM/E,KAAK8D,MAAM,KAAKtE,OAAO,GAAW,KAANG,GAC9CqF,EAAgBX,EAAUP,MAAM,KAAKtE,OAAO,GAAW,KAANG,MAGnDM,IAAW8E,EAAM9E,SAAuB,gBAA0C,IAA7BmE,EAAOa,oBAAiD,QAAjBF,EAAM9E,cAAyB,KAG3H+E,EAAcvE,OAASqE,EAAUrE,QAA8C,MAApCqE,EAAUA,EAAUrE,OAAS,UACpE,EAIFyE,EAAUJ,EAAUtF,OAAO,CAAC2F,EAAM3E,SACjC4E,EAAUZ,EAAca,KAAKF,GAC7BG,EAAgBX,EAAsBU,KAAKF,GAC3CI,EAAYJ,EAAK/F,QAAQ,IAAIqF,UAAUL,EAAOM,iBAAmB,WAAY,IAAItF,QAAQ,IAAIqF,kBAAkBL,EAAOM,iBAAmB,OAAQ,WAEnJU,GACCJ,EAAcxE,OACP+E,GAAWP,EAAcxE,KAGhC8E,IAIKN,EAAcxE,IAIhB2E,IAASH,EAAcxE,KAE7BC,cAGEyE,GAA+C,MAApCJ,EAAUA,EAAUrE,OAAS,IAAcuE,EAAcvE,OAASqE,EAAUrE,WACjF,KAAOuE,EAAcQ,OAAO,EAAGV,EAAUrE,UAG5CyE,OAGLL,QACI,IAAIA,EAAOtG,QAASsG,EAAMtG,QAAoBqG,UAAAA,EAAWa,MAAOnB,IAKlEoB,eAAQvB"}