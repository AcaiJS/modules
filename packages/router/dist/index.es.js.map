{"version":3,"file":"index.es.js","sources":["../src/utils/context.ts","../src/modules/route.ts","../src/utils/buildQueryParams.ts","../src/modules/router.ts"],"sourcesContent":["// Interfaces\r\nimport Options \t\t\t\t\tfrom \"../interfaces/routeOptions\"\r\nimport Route \t\t\t\t\tfrom \"../interfaces/route\"\r\nimport methodTypes\t\t\t\tfrom \"../interfaces/method\"\r\nimport RouteOptionsInterface\tfrom \"../interfaces/routeOptions\"\r\n\r\n// -------------------------------------------------\r\n// Properties\r\n// -------------------------------------------------\r\n\r\nlet context\t\t: Options \t\t\t\t\t\t\t\t\t= {options:{}}\r\nlet routes\t\t: Route[] \t\t\t\t\t\t\t\t\t= []\r\nlet cbs\t\t\t: (() => void)[] \t\t\t\t\t\t\t= []\r\nlet macros\t\t: Record<string, (...args: any[]) => void> \t= {}\r\n\r\n// -------------------------------------------------\r\n// Context\r\n// -------------------------------------------------\r\n\r\nexport const getContext = (): Options => context\r\n\r\nexport const setContext = ({options, ...newContext}: Partial<Options>, lastoptions: Options[\"options\"]): void => {\r\n\tconst newoptions = {...lastoptions}\r\n\r\n\tif (options) {\r\n\t\tObject.keys(options).forEach(key => {\r\n\t\t\tif (!key.match(/^!/)) {\r\n\t\t\t\tif (Array.isArray(options[key]) && Array.isArray(lastoptions[key])) {\r\n\t\t\t\t\tconst arr = options[key] as string[]\r\n\t\t\t\t\tnewoptions[key] = [...(lastoptions[key] as string[]).filter(i => !arr.find(x => x === i)), ...arr]\r\n\t\t\t\t}\r\n\t\t\t\telse if (typeof options[key] === \"object\" && typeof lastoptions[key] === \"object\") {\r\n\t\t\t\t\tnewoptions[key] = {...(lastoptions[key] as Record<string, string>), ...(options[key] as Record<string, string>)}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewoptions[key] = options[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnewoptions[key.replace(/^!/, \"\")] = options[key]\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tcontext = { ...newContext, options: {...newoptions} }\r\n}\r\n\r\nexport const clearContext = (): void => {\r\n\tcontext = {options:{}}\r\n}\r\n\r\n// -------------------------------------------------\r\n// Routes\r\n// -------------------------------------------------\r\n\r\nexport const getRoutes = (): typeof routes => routes\r\n\r\nexport const addRoute = (view: string, path: string, method: methodTypes, options: Partial<Options>) => {\r\n\t// gather data\r\n\tconst { prefix, ..._context } = getContext()\r\n\tconst completepath = `/${(prefix === undefined ? \"/\" : prefix) + path}`.replace(/\\/$/, \"\").replace(\r\n\t\t/^(\\\\+|\\/+)/gm,\r\n\t\t\"/\",\r\n\t)\r\n\tconst clearview = typeof view === \"string\" ? view\r\n\t\t.replace(/(\\\\+|\\/+)/gm, \"/\")\r\n\t\t.replace(/(\\\\|\\/)$/gm, \"\")\r\n\t\t.replace(/^(\\\\|\\/)/gm, \"\"):view\r\n\r\n\t// push to routes\r\n\troutes.push({\r\n\t\tfile: clearview,\r\n\t\tpath: completepath,\r\n\t\tmethod,\r\n\t\toptions: {\r\n\t\t\t..._context.options,\r\n\t\t\t...options,\r\n\t\t},\r\n\t})\r\n\r\n\tconst index = routes.length - 1\r\n\r\n\treturn {\r\n\t\toptions: (newoptions: RouteOptionsInterface[\"options\"]) => {\r\n\t\t\troutes[index].options = {\r\n\t\t\t\t...routes[index].options,\r\n\t\t\t\t...newoptions,\r\n\t\t\t}\r\n\t\t},\r\n\t}\r\n}\r\n\r\nexport const clearRoutes = (): void => {\r\n\troutes = []\r\n}\r\n\r\n// -------------------------------------------------\r\n// Context\r\n// -------------------------------------------------\r\n\r\nexport const getCallbacks = (): typeof cbs => cbs\r\n\r\nexport const addCallback = (newCallback: () => void): void => {\r\n\tcbs.push(newCallback)\r\n}\r\n\r\nexport const clearCallbacks = (): void => {\r\n\tcbs = []\r\n}\r\n\r\n// -------------------------------------------------\r\n// Macros\r\n// -------------------------------------------------\r\n\r\nexport const getMacro = (name: string) => {\r\n\tif (!macros[name]) {\r\n\t\tthrow new Error(`Macro '${name}' not found`)\r\n\t}\r\n\r\n\treturn macros[name]\r\n}\r\n\r\nexport const setMacro = (name: string, callback: (...args: any[]) => void) => {\r\n\tmacros[name] = callback\r\n}\r\n\r\nexport const clearMacros = () => macros = {}\r\n","// Interfaces\r\nimport methodTypes \t\t\t\tfrom \"../interfaces/method\"\r\nimport RouteInterface\t\t\tfrom \"../interfaces/route\"\r\nimport RouteModuleInterface\t\tfrom \"../interfaces/routeMethod\"\r\nimport RouteOptionsInterface \tfrom \"../interfaces/routeOptions\"\r\n\r\n// Utils\r\nimport { addRoute, clearRoutes, getMacro, getRoutes }\tfrom \"../utils/context\"\r\nimport { addCallback, clearCallbacks, getCallbacks }\tfrom \"../utils/context\"\r\nimport { clearContext, getContext, setContext }\t\t\tfrom \"../utils/context\"\r\nimport { setMacro }\t\t\t\t\t\t\t\t\t\tfrom \"../utils/context\"\r\n\r\n// -------------------------------------------------\r\n// HTTP Methods\r\n// -------------------------------------------------\r\n\r\nconst routeAnyMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"ANY\", options)\r\n}\r\n\r\nconst routeGetMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"GET\", options)\r\n}\r\n\r\nconst routePostMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"POST\", options)\r\n}\r\n\r\nconst routePatchMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"PATCH\", options)\r\n}\r\n\r\nconst routePutMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"PUT\", options)\r\n}\r\n\r\nconst routeDeleteMethod = (path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\treturn addRoute(filePath, path, \"DELETE\", options)\r\n}\r\n\r\n// -------------------------------------------------\r\n// Helpers\r\n// -------------------------------------------------\r\n\r\nconst routeMacro = (name: string, callback: (...args: any[]) => void) => {\r\n\tsetMacro(name, callback)\r\n}\r\n\r\nconst routeUseMacro = async (name: string, ...args: any[]) => {\r\n\tconst callback = getMacro(name)\r\n\tawait callback(...args)\r\n}\r\n\r\nconst routeOptions = (options: RouteOptionsInterface[\"options\"], callback: () => void) => {\r\n\tconst c \t\t\t= { ...getContext(), options: {... options} }\r\n\tconst lastoptions\t= {...getContext().options}\r\n\r\n\taddCallback(() => {\r\n\t\tsetContext(c, lastoptions)\r\n\r\n\t\tcallback()\r\n\t})\r\n}\r\n\r\nconst routeMany = (method: methodTypes[], path: string, filePath: string, options: Partial<RouteOptionsInterface> = {}) => {\r\n\tif (method.includes(\"GET\"))\r\n\t\trouteGetMethod(path, filePath, options)\r\n\tif (method.includes(\"PUT\"))\r\n\t\troutePutMethod(path, filePath, options)\r\n\tif (method.includes(\"POST\"))\r\n\t\troutePostMethod(path, filePath, options)\r\n\tif (method.includes(\"PATCH\"))\r\n\t\troutePatchMethod(path, filePath, options)\r\n\tif (method.includes(\"DELETE\"))\r\n\t\trouteDeleteMethod(path, filePath, options)\r\n}\r\n\r\nconst routeGroup = (prefix: string, callback: () => void, options?: RouteOptionsInterface) => {\r\n\tconst cprefix \t\t= (getContext().prefix === undefined ? \"\" : getContext().prefix) + (prefix || \"\")\r\n\tconst c \t\t\t= { ...getContext(), ...options, prefix: cprefix }\r\n\tconst lastoptions\t= {...getContext().options}\r\n\r\n\taddCallback(() => {\r\n\t\tsetContext(c, lastoptions)\r\n\r\n\t\tcallback()\r\n\t})\r\n}\r\n\r\nconst routeBuild = <T = Record<string, unknown>>(clearCache = true) => {\r\n\tlet cbs = getCallbacks()\r\n\r\n\twhile (cbs.length > 0) {\r\n\t\tclearCallbacks()\r\n\r\n\t\t// run all groups\r\n\t\tfor (let i = 0; i < cbs.length; i += 1) {\r\n\t\t\tcbs[i]()\r\n\t\t}\r\n\r\n\t\t// break loop if no callbacks left\r\n\t\tcbs = getCallbacks()\r\n\t}\r\n\r\n\t// build components\r\n\tconst routes = getRoutes()\r\n\r\n\t// clear registered routes\r\n\tif (clearCache) clearRoutes()\r\n\r\n\t// filter repeated routes\r\n\tconst filteredroutes = [] as typeof routes\r\n\troutes.reverse().forEach(i => {if (!filteredroutes.find(x => x.path === i.path && x.method === i.method)) filteredroutes.push(i) })\r\n\treturn filteredroutes.reverse() as RouteInterface<T>[]\r\n}\r\n\r\nconst clearMethod = () => {\r\n\tclearRoutes()\r\n\tclearContext()\r\n}\r\n\r\n// -------------------------------------------------\r\n// Add default macro\r\n// -------------------------------------------------\r\n\r\nrouteMacro(\"resource\", (name: string, file: string) => {\r\n\trouteGetMethod(`${name}`, \t`${file}@index`)\r\n\troutePostMethod(`${name}`, \t`${file}@store`)\r\n\r\n\trouteGroup(\"/{id}\", () => {\r\n\t\trouteGetMethod(\"/\", \t`${file}@show`)\r\n\t\troutePatchMethod(\"/\", \t`${file}@update`)\r\n\t\troutePutMethod(\"/\", \t`${file}@update`)\r\n\t\trouteDeleteMethod(\"/\", \t`${file}@destroy`)\r\n\t})\r\n})\r\n\r\n// -------------------------------------------------\r\n// Exports\r\n// -------------------------------------------------\r\n\r\nconst route \t= routeAnyMethod as RouteModuleInterface\r\nroute.any\t\t= routeAnyMethod\r\nroute.get\t\t= routeGetMethod\r\nroute.post\t\t= routePostMethod\r\nroute.put\t\t= routePutMethod\r\nroute.patch\t\t= routePatchMethod\r\nroute.delete\t= routeDeleteMethod\r\nroute.options \t= routeOptions\r\nroute.group\t\t= routeGroup\r\nroute.many\t\t= routeMany\r\nroute.build\t\t= routeBuild\r\nroute.clear\t\t= clearMethod\r\nroute.macro\t\t= routeMacro\r\nroute.use\t\t= routeUseMacro\r\n\r\nexport default route as RouteModuleInterface","function stringToType (str: string) {\n\tif (str === \"true\") return true\n\tif (str === \"false\") return false\n\tif (`${parseFloat(str)}` === str) return parseFloat(str)\n\n\treturn str\n}\n\nexport default function buildQueryParams (prepath = \"\") {\n\tconst [path, ...preargs] = prepath.split(\"?\")\n\tconst args = {} as Record<string, number | string | boolean>\n\n\t(new URLSearchParams(preargs.join(\"?\"))).forEach((val, key) => args[key] = stringToType(val) || true)\n\n\treturn [path, args] as const\n}","// Interfaces\r\nimport RouteInterface from \"../interfaces/route\"\r\nimport MethodTypes from \"../interfaces/method\"\r\nimport RouterConfigInterface from \"../interfaces/routerConfig\"\r\n\r\n// Utils\r\nimport buildQueryParams from \"../utils/buildQueryParams\"\r\n\r\n/**\r\n * # Router\r\n *\r\n * Get a list of routes and find the correspondent based on the given routes.\r\n *\r\n * @param {string} path current url path to be analyzed against all routes\r\n * @param {string} method HTTP method to match to\r\n * @param {RouteInterface[]} routes list of available routes that can be matched\r\n * @param {RouterConfigInterface?} config extra config options to customize the router behaviour\r\n */\r\nconst routerModule = <Options = Record<string, string>> (path: string, method: MethodTypes, routes: RouteInterface[], config: RouterConfigInterface = {}) => {\r\n\t// prepare data\r\n\tconst sanitizedpath = path.replace(/(\\\\|\\/)^/, \"\")\r\n\tconst [clearpath, queryParams] = buildQueryParams(sanitizedpath)\r\n\tconst variablematch = new RegExp(`${config.variableEnclose || \"{\"}\\\\s*\\\\S+\\\\??\\\\s*${config.variableEnclose || \"}\"}`)\r\n\tconst optionalVariableMatch = new RegExp(`\\\\?{1}\\\\s*${config.variableEnclose || \"}\"}`)\r\n\tlet variables = {} as Record<string, string | string[]>\r\n\r\n\t// Match routes\r\n\tconst route = routes.find((route) => {\r\n\t\tvariables = {}\r\n\t\tconst splitpath = route.path.split(\"/\").filter(i => i !== \"\")\r\n\t\tconst possibleMatch = clearpath.split(\"/\").filter(i => i !== \"\")\r\n\r\n\t\t// check route http method\r\n\t\tif (method !== route.method && !(method === \"OPTIONS\" && config.allowOptionsMatch !== false) && route.method !== \"ANY\") return false\r\n\r\n\t\t// check by length\r\n\t\tif (possibleMatch.length > splitpath.length && splitpath[splitpath.length - 1] !== \"*\") {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\t// filter by the actual route\r\n\t\tconst matches = splitpath.filter((part, index) => {\r\n\t\t\tconst isVar \t\t= variablematch.test(part)\r\n\t\t\tconst isOptionalVar = optionalVariableMatch.test(part)\r\n\t\t\tconst varName \t\t= part.replace(new RegExp(`${config.variableEnclose || \"{\"}\\\\s*`), \"\").replace(new RegExp(`\\\\??\\\\s*${config.variableEnclose || \"}\"}`), \"\")\r\n\r\n\t\t\tif (isVar) {\r\n\t\t\t\tif (possibleMatch[index]) {\r\n\t\t\t\t\tvariables[varName] = possibleMatch[index]\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isOptionalVar) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn !possibleMatch[index]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn part !== possibleMatch[index]\r\n\t\t\t}\r\n\t\t}).length\r\n\r\n\t\t// add extra if necessary\r\n\t\tif (!matches && splitpath[splitpath.length - 1] === \"*\" && possibleMatch.length > splitpath.length) {\r\n\t\t\tvariables[\"*\"] = possibleMatch.splice(0, splitpath.length)\r\n\t\t}\r\n\r\n\t\treturn !matches\r\n\t})\r\n\r\n\tif (route)\r\n\t\treturn {...route, options: route.options as Options, variables, query: queryParams}\r\n\r\n\treturn undefined\r\n}\r\n\r\nexport default routerModule"],"names":[],"mappings":"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"}